                                                                      PYTHON 101
Versitile language
Very popular
Easy and forgiving- emphasizes readability- less punctuation, more key words so readable by people/ user 
 friendly
'Made for the Web'- data
Used in AI, Machine Learning and Data Science.
core language small but expanded through different 'modules'/ 'packages which extend usability
uses indentation to define scope(not differing punctuation)
quick to write and test, edit and debug
lots of open source materials and pre-written packages to construct projects quickly
often used to automate simple tasks
used in 'back end' development

Will learn:
      Basic syntax
      Outputting data and program flow
      strings and variables
      arithmetic operations, and comparisons
      Lists, Tuples, sets and dictionaries (ways of storing different types of data)
      Conditionals: if, elif statements
      while and for loops
      functions/ return statementsobjects, classes and inheritence
      List/ dictionary comprehensions and lamda functions
      Modules

mutable objects= objects that can have their values changed after assignment (list, objects, arrays)
immutable objects= objects that cannot have their valeus changed after assignment(tuple, primitive data types like boolean, numbers,null)

Brython plugin can be added to head eg
<html>
    <head>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.8.0/brython.min.js"></script>
         <!--<script type="text/javascript"
     src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.8.0/brython_stdlib.js"></script>-->
    </head>
    <body onload="brython();">
        <script type="text/python3" src="index.py"></script>
       
    </body>
</html>

odities:
      input boxes- not always seen in tutorial


                     1- Print Statement and Program flow

                     function(argument)

print("welcome")

             Print() statement
             
function that outputs to the console
a means of outputting data
good for troubleshooting to see the values at each point (like console.log())
syntax-
      print("Display this message")



          Breakpoints Using raise SystemExit
an exception in python
breaks out of the running program
syntax
     raise SystemExit()

used to stop program at a specific point
systemExit runs the exit() function in python so code is exoted safely

eg     
age = 17
if age <= 18:
    raise SystemExit('You must be older than 18!')

              syntax errors
a python errorspoints out when your syntax is incorrect
look for the arrow pointing to your error 

aka parsing errors
      parser repeats the line where the error was detected in the terminal
      caret (^) points to the earliest line where the error occurs
      text after the SyntaxError may suggest a fix
      filename and linenumber are printed

                             Logic errors
an error with the logic of your code
code that does something other than what you intended
fix by debugging the code

common errors inc- using wrong variable name
                incorrect indentation
                wrong number typesincorrect operator precedence
                wrong boolean valuesout-by-one error

neatly laying code out to PEP8 standards helps readability- copying and pasting large chunks causes errors

use print() statements to debug


                       Declaring variables
like boxes to store, modify, reference values/ data
gives values meaning and recall values whenever needed
use variables to build up data necessary for computer program

stored in RAM (random access memory)

rules for variables:    variable names must start with a regular letter (not a number)

PEP8 is standard for writing python code-   (https://www.python.org/dev/peps/pep-0008/)
          use lowercase for variable names and spaces shown with underscore
                  my_var
            python case sensitive so ve careful

            eg     
            my_number = 5
            print(my_number)

            num = 42
print(num)
temporary_password = True
print(temporary_password)


                     Functions
allow us to group pieces of logical statements that will perform a particular task
Most code will be broken out into functions. Functions are a grouping of statements that work together to perform any actions that we may need

def: This is the keyword that we use to tell Python that we are creating a function definition. 
print_message: This is the name that we’ve decided to give our function. Be sure to 
               give your functions meaningful names so that when other people try to 
               use your code, they’ll able to make sense of what the function does 
               without having to read the code in the function
(): The parentheses denote the parameters that a function takes. 

eg
def print_message():
    print("Hello World!")

print_message()


                     Python Frameworks, Modules and Libraries
Prewritten Python code
Allows quick construction of projects
by using functions from frameworks or Libraries
    eg NumPy    pandas     Scrapy     django

module= a set of lines of code that have been written for a purpose

eg
def division(numerator, denominator):
    result = numerator / denominator
    return result

^above could be saved in a file called divide.py- it could now be considered a 
         module- this could then be imported everytime you need to divide
        eg
        import divide

        divide.division(4, 2)

Library= code that has been written to be used in many applications with common functionality
          eg- arithmetic functions
    A library can be imported into any application where you need the functionality

Framework=  a collection of packages or modules that allows a developer to write web 
        applications. 
        deals with all the web protocols leaving you free to write the code specific 
        to your web app 
        support with activities such as receiving form parameters, dealing with 
        cookies or handling session data. 
        To use a Framework, you write code that conforms to the conventions of the 
        framework and effectively delegate responsibility for the standard web app  
        stuff allowing you to concentrate on your application logic.




                                         Data types
types of data used in python
different data can do different things
can check a data type directly or check the type stored by a variable

boolean: True/ false
Text/ string (str)
Numeric types: integer (integer)
            float and complex numbers

data types can be stored in other data types
  eg- hold a sequence in a list, type or range
    can map data using a dictionary (dict)

can use type() function to find out a data type
or
isinstance() will return true or false
eg
my_var = 2
type(my_var)
type(2)
isinstance(my_var, int)

console= 
<class 'int'>
<class 'int'>
True

eg
print(type("Hello, World!"))                         
print(type(42))
print(type(3.145))
print(type(1j))
print(type(["egg", "bacon", "spam"]))
print(type(("egg", "bacon", "spam")))
print(type(range(6)))
print(type({"name" : "John", "age" : 80}))
print(type({"egg", "bacon", "spam"}))
print(type(True))
print(isinstance(3.14, int))

<class 'str'>
<class 'int'>
<class 'float'>
<class 'complex'>
<class 'list'>
<class 'tuple'>
<class 'range'>
<class 'dict'>
<class 'set'>
<class 'bool'>
False
__________________________challenge
itm_one = 10
itm_two = 21.56
itm_three = 'A string of text'
itm_four = True
           (print the type of each item)
print(type(itm_one))
print(type(itm_two))
print(type(itm_three))
print(type(itm_four))
                outputs
 <class 'int'>
<class 'float'>
<class 'str'>
<class 'bool'>  


----------------------------Integers, floats, decimals

types of data- numeric types

Integers-  (int)      whole number
floats/ floating point numbers    number followed by a decimal point eg 12.73
complex numbers

standard python library also includes
      fractions.Fraction   for rationals
      decimal.decimal

constructors int(),     float()   cmplex()
eg# Declare your variables here
num1 = 77
num2 = 3.15


# These will print the value TYPES to the terminal 
print(type(num1))
print(type(num2))

outputs
<class 'int'>
<class 'float'>


-------------------------------------None
a single object
signifies 'empty' or 'no value here'
use syntax     None

not the same as 0 or false or an empty string

None used to reasign the variable to None
has data type of NoneType
ega = 1
a = None
print(a)

def donothing():
    b = 0

print(donothing())
outputs
None
None


----------------------------String variables
a way of storing strings in memory
assign a variable a value of string
eg
# define your variable here
parrot = "It's not pining, it's passed on! This parrot is no more! It has ceased to 
          be!"
print(parrot)


----------------------------------------Converting between Data types
ability to convert from one data type to another
allows you to choose appropriate data type for calculation
by using built-in python functions

int()         float()          str()

Function	What it converts
int()	     Converts to an integer
float()	     Converts to a floating-point number
hex()	     Converts a number to a hexadecimal string
oct()	     Converts a number to a octal string
tuple()	     Converts to a tuple
set()	     Converts to a set
list()	     Converts to a list
dict()	     Converts a tuple into a dictionary
str()	     Converts a number into a string

------------ challenge
result = 40 + float("2.2")
print(result)

result_two = "The answer to the ultimate question is " + str(42)
print(result_two)
output
42.2
The answer to the ultimate question is 42


-----------------------------------------------PYTHON SPECIFIC OPERATORS

                                 __Storing Values with Assignment OPERATORS__
assigning a variable value
stores the value associated with the variable name
by using the assignmant operator    =

num_1 = 3
num_2 = 2

total = num_1 + num_2
print(total)                  logs (5)

______________________________________________Basic math with Arithmetic operators OPERATORS__
Basic arithmetic
counting
by using arithmetic operators

+  addition

-   subtraction

*  multiplication

/  division     (always results in a float)

//  floor division   (returns and integer) rounds answer down to the nearest whole number and returns as an integer

**  exponention     (exponent- to the power of   eg 5 ** 5 is 5 to the power of 5   5 * 5 * 5 * 5 * 5)

%  modulus   - divides the first number by the second and then returns only the remainder   eg  5 % 5=  0
                                                                                              18%7 = 4
                                                                                              (18/7=2 r 4)
               modulus often used to find odd or even numbers
                                      convert mins into hrs and mins eg convert 10900mins into hrs
                                                       10900 % 60

Order of operations       PEDMAS- parentheses
                                  exponents
                                  division
                                  multiplication
                                  addition
                                  subtraction

----eg
print(2 + 2)                     
print(4 - 2)
print(2 * 3)
print(9 / 3)
print(2 ** 3)
print(18 % 7)
print(10900 % 60)
Output
4
2
6
3.0
8
4
40

--------------------------challenge

product = 72
total_cost = product + product * 0.21

print(total_cost)                         returns 87.12

______________________________________________Incrementing and Decrementing_
changing a value in increments
incorporates assignment and arithmetic operators
arithmetic operator placed before assignment orerator

eg a running total

+= addition and       -= subtraction and       *= multiplication and         /= division and

       **- exponent and     %= modulus and     //= floor division and

combining the arithmetic operator and the assignment operator

+= increments a vaviable by adding a value and reassigning the result to the variable

_______eg
variable_one = "hello "
variable_two = "world"

variable_one += variable_two                
print(variable_one)                     returns hello world   (variable_one reassigned to be both)
print(variable_two)                     returns    world

x = 2
x *= 3
print(x)                                returns   6

__________________________challenge
num = 100
print(num)       returns 100
num = 50
print(num)       returns 50
num_b = 100
print(num_b)     returns 100
num_b %= 3
print(num_b)      returns 1      (100/3 answer  has a remainder of 1)


______________________________________________String Formatting_

process of adding placeholder values to a string to be filled at a later point
injects text into an empty string at a later point to make it more meaningful
by using      f-strings    syntax

         f'{string or expression}'

         f"{variable}"

_______eg
name = input("What's your name? ")
# Here we don't need age to be a number as we are not
# going to do any calculations with it so we don't need to wrap the
# input() in the str() method
age = input("What's your age: ")

# The Modern way of formatting a string
print(f"Hello {name}, you are {age} years old")

__________________________challenge
name = "Igor"
age = 35

# write your code here
concat_string = name + " is " + str(age)
print(concat_string)

f_string = f"{name} is {age}"
print(f_string)                                               Igor is 35
                                                              Igor is 35


______________________________________________String methods_
built in python methods that can be used on strings
allow you tho manipulate string values
use by using a dot (.) after the string followed byt the method name and a pair of brackets

Method	       Description
capitalize()	Capitalizes the first character of the string
center()	   Centers string
count()	       Returns a count of times a specified value occurs in the string
encode()	   Returns an encoded version of the string (use decode() to decode)
endswith()	    Returns True if the string ends with a specified suffix
expandtabs()	Sets the tab size in spaces of the string
find()	        Returns the lowest index position of where a specified character was found
index()	       Searches for a specified value and returns the position of where it was found or an error if not found
isalnum()	   Returns True if all characters are alphanumeric
isalpha()	   Returns True if all characters are alphabetic
isdigit()	    Returns True if all characters are digits
islower()	   Returns True if all characters are lower case
isspace()	   Returns True if all characters are whitespace
istitle()	   Returns True if the string is titlecased
isupper()	   Returns True if all characters in the string are upper case
join()	       concatenates string
ljust()	       Returns a left justified version of the string
lower()	       Converts a string into lower case
lstrip()	   Returns a left trim version of the string
partition()	   Returns a tuple where the string is parted into two strings and the separator
replace()	    Returns a string where a old value is replaced with a new value
rfind()	       Searches highest index in the string for a specified value
rindex()	    Same but with error if nothing found
rjust()	         Returns a right justified version of the string
rpartition()	Returns a tuple where the string is parted into three parts
rsplit()	     Splits the string at the specified separator, and returns a list
rstrip()	     Returns a right trim version of the string
split()	        Splits the string at the specified separator, and returns a list
splitlines()	Splits the string at line breaks and returns a list
startswith()	Returns true if the string starts with the specified value
strip()	        Returns a trimmed version of the string
swapcase()	    Swaps cases, lower case becomes upper case and vice versa
title()	        Converts the first character of each word to upper case
translate()	    Returns a translated string
upper()	       Converts a string into uppercase
zfill()	       Fills the string with a specified number of 0 values at the beginning

_______eg
my_string = "HELLO WORLD"
my_string_lower_case = my_string.lower()                          

print(my_string_lower_case)                                      returns hello world

my_string_2 = "hElLo WorLD"
my_string_2_upper_case = my_string_2.upper()

print (my_string_2_upper_case)                                     returns HELLO WORLD
print (my_string.isalpha())                                        returns  False

greetings = my_string.replace("WORLD", "Dave")
print(greetings)                                                    returns  HELLO Dave

motion = ("jump", "walk", "run")
new_string = "ing ".join(motion)
print(new_string)                                                    returns jumping walking run

print(my_string_2.split(" "))                                   returns ['hElLo', 'WorLD]

spaced_string = "     42       "
print(spaced_string.strip())                                     returns 42

__________________________challenge

dwarves = "Grumpy, Dopey, Doc, Happy, Bashful, Sneezy, Sleepy"
print(dwarves)                                returns   Grumpy, Dopey, Doc, Happy, Bashful, Sneezy, Sleepy


# write your code here
lowercase_string = dwarves.lower()
print(lowercase_string)                returns grumpy, dopey, doc, happy, bashful, sneezy, sleepy

commas_removed = lowercase_string.replace(",", "")
print(commas_removed)                     retuns grumpy  dopey  doc  happy  bashful  sneezy  sleepy

split_list = commas_removed.split()
print(split_list)                          returns  ['grumpy', 'dopey', 'doc', 'happy', 'bashful', 'sneezy', 'sleepy']


__________________________________________________________PYTON SPRCIFIC COMPARATORS

_____________________________________________________Comparing Values with Comparison operators
a way to compare values
compares values of variables
by using comparison operators

         < less than                       > greater than
         <=  less than or equal to        >= greater than or equal to 
         == equal to                      != not equal to

_______eg
print('Hello, World!' == 'Hello, World!')    returns True
print(2!=2)                                    returns false
print([1,2]<[1,2,3])                         returns true
print(float(2)>=int(2))                      returns True
print('a'<'A') #This is False as 'a' is Unicode 97 where 'A' is 65      returns false

__________________________challenge

a = 10
b = 5

print(a == b)
print(a < b)
print(a <= b)
print(a > b)
print(a >= b) 

_____________________________________________________Determining Truth with Logical operators
a way to combine conditional statements using logical operators

_______eg
print(True and True)           True
print(True and False)          False
print(True or False)           True
print(not (4 < 5 and 4 < 10)) False

__________________________challenge
# Define variables a and b
a = 10
b = 5

# Define result_one to check if both a is greater than b and a is greater than 10
result_one = (a > b and a > 10)

# Define result_two to check if either a is equal to 5 or b is less than 5
result_two = (a == 5 or b < 5)

# Define result_three to negate result_two
result_three = not result_two

# Print the results
print(result_one)   # Expected output: False
print(result_two)   # Expected output: False
print(result_three) # Expected output: True


________________Truthy and Falsy values challenge
# Assign values to the variables
a = []        # An empty list is considered False
b = ""        # An empty string is considered False
c = "Non-empty string"  # A non-empty string is considered True
d = 0.0       # 0.0 (float) is considered False
e = 1         # Any non-zero integer is considered True

# Print the boolean values of the variables
print(bool(a))  # Expected output: False
print(bool(b))  # Expected output: False
print(bool(c))  # Expected output: True
print(bool(d))  # Expected output: False
print(bool(e))  # Expected output: True


_____________________________________________________Equality vs Identity
checking the identity of an object beyond matching values or types by using identity operators

check if something has a unique identity
each object in python does have a unique identifier
Not all equal values will have the same identifier
                                          is     /     is not
       _______eg
# Assign a value to num
num = 1

# Assign num to num_two
num_two = num

# Check if num is equal to num_two
equality_check = (num == num_two)

# Get the IDs of num and num_two
id_num = id(num)
id_num_two = id(num_two)

# Print the results
print(equality_check)  # Expected output: True, because num and num_two have the same value
print(id_num)          # Prints the memory ID of num
print(id_num_two)      # Prints the memory ID of num_two

_____________________________________________________Checking Containment with Containment operators
a keyword that checks if a value is present in a sequence
                           keyword  =  in
            
            in operator returns true or false

      'Program' in 'Programming'
      'Program' not in 'Programming'      (not keyword can chesk for absence)

_______eg

print('Program' in 'Programming')       #true
print('spam' in ['spam', 'egg'])         #true
print('sausage' not in ['spam', 'egg'])   #true    

__________________________challenge
# Check if the string "rat" is in the string "crate"
print("rat" in "crate")  # Expected output: True

# Check if the string "ink" is NOT in the string "sink"
print("ink" not in "sink")  # Expected output: False

# Check if the string "robbie" is in the list ["gary", "howard", "mark", "jason"]
print("robbie" in ["gary", "howard", "mark", "jason"])  # Expected output: False



__________________________________________________________PYTON FLOW CONTROL

______________________________________________If/ Else statements
if    and     else clauses
provide us with the ability to handle different Conditions


_______eg
number = int(input("Please enter a number:"))

if number == 5:
    print(f"{number} is equal to 5")
else:
    print(f"{number} is not equal to 5")


__________________________challenge 
a = 10
b = 20
result = None

# Write your if statement here:
if a == b:
    result = "a has the same value as b"
else:
    result = "a has not got the same value as b"

# Print the result
print(result)  # Expected output: "a has not got the same value as b"


______________________________________________Ternary expressions in python
If expression   allows us to write short hand if statements

_______eg
my_boolean = False

my_string = "Hello" if my_boolean else "World"

print(my_string)  # Expected output: "World"


__________________________challenge
Assign a ternary conditional statement to the variable result, that evaluates to True if the variable full_access is True or False otherwise

full_access = True
result = True if full_access else False

print(result)  # Expected output: True

______________________________________________________Python Flow CONTROL
conditional statements control which parts of code run depending on certain Conditions

Fizz buzz
The FizzBuzz game contains some  simple logic for kids. You are given the number.
If the number is divisible by 3, you reply "Fizz",  if the number is divisible by 5, you reply "Buzz".
If the number is divisible by both 3  and 5 you reply "FizzBuzz". And if the number
doesn't meet any of these conditions - i.e., it can't be divided by 3 or 5, then you simply reply with the number given.

num =  2

if num % 3 == 0 and num % 5 == 0:
    print("FizzBuzz")
elif num % 3 == 0:
    print("Fizz") 
elif num % 5 == 0:
    print("Buzz")
else:
    print(num)


     Lucid chart for logic diagrams https://www.lucidchart.com/pages/


______________________________________________________Multiple conditions if/elif/else
if-else if-else expression
allows us to include multiple else blocks
using elif

_______eg
number = int(input("Please enter a number:"))

if number > 5:
    print(f"{number} is greater than 5")
elif number < 5:
    print(f"{number} is less than 5")
else:
    print(f"{number} is not greater than, or less than 5. Therefore, {number} must be equal to 5.")


________________________________challenge

day = 'Friday'

if day == "Monday":
    print("Meeting at 9:00")
elif day == "Wednesday":
    print("Meeting at 2:00")
elif day == "Friday":
    print("Meeting at 4:00")
else:
    print("No meetings today")


______________________________________________________Nested if/else
nested conditions
provide a means of implementing additional if/else ladders inside existing if-else blocks
eg- if need to run additional checks within a blocks

use indentation to define scope

_______eg
exit_program = True
manual_override = False
critical_systems_shutdown = False

if not exit_program and not critical_systems_shutdown:
    if manual_override:
        print("Shutting system down manually")
    else:
        print("This program will not exit just yet")
elif exit_program and critical_systems_shutdown is not True:
    print("Critical systems must be safely shut down before exiting the program")
else:
    print("This program will now be terminated...")

________________________________challenge
admin = True
update_required = True

if admin:
    if update_required:
        print('You are authorized to update')
    else:
        print('No update required')
else:
    print('You need admin privileges to do this')



__________________________________________________________________________PYTHON ITERATION

____________________________________________________________For loops
provide us with the ability to iterate a sequeence of items
and perform a task for each item in the collection
used in lists, tuples, dictionaries, sets, strings
no need for indexing

us 'for' keyword
 then have an 'item' = a variable name  (usually the singular of the sequence name you are iterating over)

a loop continues until the last item is reached and then the loop is exited

_______eg

languages = ["HTML", "CSS", "JavaScript"]
for language in languages:
  print(language)                         returns a list of HTML   CSS    JavaScript


for character in "Python":
  print(character)                       returns a list    P    Y     T     H    O    No

______ range()
used to loop through the code a specific number of times
range() function will generating a sequence of numbers- when passing through an argument of 5, we say the sequence needs to be comprised of 5 numbers
(remember starting from 0)

_______eg
foods = ['bacon', 'sausage', 'egg', 'spam']

for ind in range(len(foods)):
	# In this example only the index is iterated over not the value
    print(ind, foods[ind])
print(foods)
# In this case we need to calculate the length of the foods collection
# Then we generate a range of integers equal to that length
# Then we iterate over that range of integers
CONSOLE
0 bacon
1 sausage
2 egg
3 spam
['bacon', 'sausage', 'egg', 'spam']


________________________________challenge
# Create a variable named users and assign it a list value
users = ['anna', 'chris', 'brian']

# Loop over the users list using range() and len()
for i in range(len(users)):
    # Update each entry to start with a capital letter using capitalize()
    users[i] = users[i].capitalize()

# Print the updated users list
print(users)


____________________________________________________________while loops
provide us with the ability to perform repetitive tasks
eg- run the same good code over and over again

can run indefinately or as long as a condition is true

_______eg
# Set the initial value for the countdown number
countdown_number = 10

# Print messages indicating the start of the countdown
print("Initiating Countdown Sequence...")
print("Lift Off Will Commence In...")

# Start the countdown sequence using a while loop
while countdown_number > 0:
    # Print the current countdown number and indicate it is in seconds
    print(f"{countdown_number} seconds...")

    # Decrease the countdown number by 1 for the next iteration
    countdown_number -= 1

# When the countdown reaches 0, print the final message
print("And We Have Lift Off!")

CONSOLE
Initiating Countdown Sequence...
Lift Off Will Commence In...
10 seconds...
9 seconds...
8 seconds...
7 seconds...
6 seconds...
5 seconds...
4 seconds...
3 seconds...
2 seconds...
1 seconds...
0 seconds...
And We Have Lift Off!

_______eg
# Set the initial value for the variable play_game to True
play_game = True

# Start a while loop that continues as long as play_game is True
while play_game:
    # Prompt the user whether they want to continue playing
    continue_playing = input("Would you like to continue playing the game? y/n ")

    # Check the user's input
    if continue_playing.lower() == "y":
        # If the user inputs 'y', inform them that they have decided to continue playing
        print("You have decided to continue playing the game.")
    elif continue_playing.lower() == "n":
        # If the user inputs 'n', inform them that the game is closing and set play_game to F

______________________challenge
# Initialize a variable to start the loop at 0
number = 0

# Start a while loop that runs until number reaches 10
while number < 10:
    # Print the current value of number
    print(number)
    # Increment the value of number for the next iteration
    number += 1

__________________________________________ Controlling Iteration (Break, Continue and Pass)
controlling iteration by keyword
allows a break or skip of code
sometimes need to break out of a loop or skip a step at a certain point- usually determined by a conditional check

In Python, we can break out of and continue running iterations in loops. The break keyword will stop executing the list, and the 
continue keyword will skip ahead to the next iteration. A pass statement disregards the condition, and the program carries on as 
though the condition statement was not there.

break statement- allows exit from the loop based on an external conditio- the loop finishes at that point

continue statement- allows to skip over part of the loop based on external conditions- program will then go back to the 
                     beginning of the loop

pass statement- allows to handle the condition without the loop being affected in any way (loop carries on as normal)

___ eg break
for number in range(10):
    if number == 5:
        break    # break here

    print(f'Number is  {number}')

print('Left the loop')
CONSOLE'

Number is  0
Number is  1
Number is  2
Number is  3
Number is  4
Left the loop

_______eg continue

for number in range(10):
    if number == 5:
        continue    # continue here

    print(f'Number is  {number}')

print('Left the loop')
CONSOLE
Number is  0
Number is  1
Number is  2
Number is  3
Number is  4
Number is  6
Number is  7
Number is  8
Number is  9
Left the loop

_______eg
for number in range(10):
    if number == 5:
        pass    # pass here

    print(f'Number is  {number}')

print('Left the loop')
CONSOLE
Number is  0
Number is  1
Number is  2
Number is  3
Number is  4
Number is  5
Number is  6
Number is  7
Number is  8
Number is  9
Left the loop

______________________challenge- break
x = 0

while True:  # Infinite loop
    if x == 8:
        break  # Break the loop if x is equal to 8
    else:
        print(x)  # Print the value of x
        x += 1    # Increment x by 1 each time
#returns 0-7 in a list

______________________challenge- pass
x = 0

while x < 14:
    if 4 < x < 11:
        pass
    else:
        print(x)
    
    x += 1

______________________________________________________________ Nested Iteration
when one loop is inside another
allows you to iterate through an inner loop on each iteration of an outer loop.
by using 4 spaces of indentation

_______eg

i = 2  # Initialize the outer loop variable i to 2
while i < 10:  # Outer loop: Continue while i is less than 10
    j = 2  # Initialize the inner loop variable j to 2
    while j <= i/j:  # Inner loop: Continue while j is less than or equal to the square root of i
        if not i % j:  # Check if i is divisible by j without any remainder
            break  # If i is divisible by j, exit the inner loop
        j += 1  # Increment j by 1 for the next iteration of the inner loop
    if j > i/j:  # Check if the loop condition j <= i/j is no longer satisfied, implying i is a prime number
        print(f'{i} is a prime number')  # If j > i/j, print that i is a prime number
    i += 1  # Increment i by 1 for the next iteration of the outer loop

    CONSOLE
2 is a prime number
3 is a prime number
5 is a prime number
7 is a prime number

______________________challenge
x = 0  # Initialize the variable x to 0
while x <= 3:  # Outer while loop: Loop while x is less than or equal to 3
    y = 200  # Initialize the variable y to 200 at the start of each iteration of the outer loop
    while y <= 203:  # Inner while loop: Loop while y is less than or equal to 203
        print(x, y)  # Print the current values of x and y
        y += 1  # Increment y by 1 for each iteration of the inner loop
    x += 1  # Increment x by 1 for each iteration of the outer loop


_________________________________________________________________________________________PYTHON DATA STRUCTURES

______________________________________________________________Lists

list = a collection of items
collects data
place items inside [square brackets] and separate them with commas_removed

_______eg
fruits = ['apple', 'orange', 'banana', 'pear', 'plum']

# Print all fruits
for fruit in fruits:
    print(fruit)

print()

# Get an item located in a list
second_item = fruits[1]
print(second_item)
print()

# Add an item to the list
fruits.append('cherries')
print(fruits)
print()

# Reverse the list
fruits.reverse()
print(fruits)

# Sort the list alphabetically:
fruits.sort()
print(fruits)

CONSOLE

apple
orange
banana
pear
plum
orange
['apple', 'orange', 'banana', 'pear', 'plum', 'cherries']
['cherries', 'plum', 'pear', 'banana', 'orange', 'apple']
['apple', 'banana', 'cherries', 'orange', 'pear', 'plum']

_______________________________________________challenge
# Create a variable named all_numbers and assign it the list value
all_numbers = [1, 5, 44, 22, 13, 17, 56, 3, 88, 9, 97]

# Create an empty list named big_numbers
big_numbers = []

# Create a for loop to iterate through the all_numbers list
for number in all_numbers:
    # Inside the loop, check if the number is greater than 40
    if number > 40:
        # If the number is greater than 40, add it to the big_numbers list
        big_numbers.append(number)

# Print the values of all_numbers and big_numbers
print("All numbers:", all_numbers)
print("Big numbers:", big_numbers)


______________________________________________________________List slicing and indexing
slice notation
allows us to create sub-lists from lists

______eg-   INDEXING
fruits = ["apple", "banana", "peach", "pear", "plum", "orange"]
# As lists are zero-indexed index 0 is the first element
print(fruits[0])
# Using an index of -1 gives the last element. Negative indexing counts from the right
print(fruits[-1])
print(fruits[2])

CONSOLE 
apple
orange
peach


______eg-   slicing

fruits = ["apple", "banana", "peach", "pear", "plum", "orange"]
print(fruits[0:2])
CONSOLE
['apple', 'banana']

fruits = ["apple", "banana", "peach", "pear", "plum", "orange"]
print(fruits[0:4:2])
CONSOLE
['apple', 'peach']

_______________________________________________challenge

# Get the value of "John" out of the names list and assign it to a variable named name
name = names[2]  # Index 2 corresponds to the third element in the list, which is "John"
print(name)  # Print the value of the variable name, which is "John"

# Slice the names list starting at index 2 and ending at index 4 (exclusive), assign it to a variable named two_names
two_names = names[2:4]  # This slice includes elements at index 2 and 3, which are ["John", "Sally"]
print(two_names)  # Print the value of the variable two_names, which is ["John", "Sally"]

# Slice the names list starting at index 1, ending at index 6 (exclusive), with a step value of 2, assign it to a variable named other_names
other_names = names[1:6:2]  # This slice includes every second element from index 1 to 5, which are ["Betty", "Sally", "Steven"]
print(other_names)  # Print the value of the variable other_names, which is ["Betty", "Sally", "Steven"]

console
John
['John', 'Sally']
['Betty', 'Sally', 'Steven']


______________________________________________________________List methods
methods to manipulate the list
can be applied on list objects

Method	               Description
list.append(x)	      Add an item to the end of the list.
list.extend(list)	Extend the list by appending another list.
list.insert(i, x)	Insert an item at a given position. The first argument is the index of the element before which to insert
list.remove(x)	      Remove the first item from the list whose value is equal to x. It raises a ValueError if there is no such item.
list.pop(i)	        Remove the item at the given position in the list, and return it. If no index is specified, a.pop() removes and returns the last item in the list.
list.clear()	      Remove all items from the list.
list.index(x, start, end)	       Return zero-based index in the list of the first item whose value is equal to x. Raises a ValueError if there is no such item.The optional arguments start and end are interpreted as in the slice notation.
list.count(x)	         Return the number of times x appears in the list.
list.sort(key=None, reverse=False)	       Sort the items of the list in place
list.reverse()	       Reverse the elements of the list in place.
list.copy()	         Return a copy of the list. Equivalent to a[:].

______eg
menu = ['eggs', 'bacon', 'spam', 'spam']
print(menu)
print(menu.count('spam'))
print(menu.count('eggs'))
print(menu.index('eggs'))
print(menu.reverse())
print(menu)
print(menu.append('lobster thermidor'))
print(menu)
print(menu.sort())
print(menu)
print(menu.pop())

console-------

['eggs', 'bacon', 'spam', 'spam']
2
1
0
None
['spam', 'spam', 'bacon', 'eggs']
None
['spam', 'spam', 'bacon', 'eggs', 'lobster thermidor']
None
['bacon', 'eggs', 'lobster thermidor', 'spam', 'spam']
spam

_______________________________________________challenge
# Define a variable named crew and assign it the list value
crew = ["Jean-Luc", "Wesley", "Warf", "Deanna", "William", "Data", "Geordie", "Tasha"]

# Print the value of crew to the console
print("Initial crew:", crew)

# Using the pop() method, remove the last item from the crew list
crew.pop()

# Print the value of crew to the console after pop
print("After pop:", crew)

# Using the append() method, add the string "Beverly" to the crew list
crew.append("Beverly")

# Print the value of crew to the console after append
print("After append:", crew)

# Using the extend() method, add the strings "Miles" and "Guinan" to the crew list
crew.extend(["Miles", "Guinan"])

# Print the value of crew to the console after extend
print("After extend:", crew)

# Use the sort() method to sort the crew list by the length of each string, and reverse the list
crew.sort(key=len, reverse=True)

# Print the value of crew to the console after sort
print("After sort:", crew)


______________________________________________________________TUPLES
a collection of items
collects dataplace items inside parentheses and separate with commas

eg     ("apple", "banana", "cherry")

Creating a tuple is referred to as packing. So when you want to get the values back, it is referred to as unpacking.
It is also possible to get a value with indexing.

why choose a tuple over a list? As it is not changeable, it can be used where you have a constant set of values. 

______eg
empty = ()
singleton = 'hello',
tup = 12345, 54321, 'hello!' # packing two ints and a string in a tuple
print(empty)
print(singleton)
print(tup)
print(tup[1])
x, y, z = tup # unpacking tuple into variables
print(z)
CONSOLE
()
('hello',)
(12345, 54321, 'hello!')
54321
hello!


_______________________________________________challenge
# Create a tuple variable named cars and pack it with the values "Tesla", "BMW", and "Ferrari"
cars = ("Tesla", "BMW", "Ferrari")

# Print the cars variable to the terminal
print("Cars tuple:", cars)

# Create a variable named get_car and use tuple indexing to pull out the "BMW" value from the cars tuple
get_car = cars[1]

# Print the get_car variable to the terminal
print("Get car:", get_car)

# Unpack the cars tuple and assign its values to variables named car_one, car_two, and car_three
car_one, car_two, car_three = cars

# Print the car_one, car_two, and car_three variables to the terminal
print("Car one:", car_one)
print("Car two:", car_two)
print("Car three:", car_three)
CONSOLE
Cars tuple: ('Tesla', 'BMW', 'Ferrari')
Get car: BMW
Car one: Tesla
Car two: BMW
Car three: Ferrari


______________________________________________________________Dictionaries

provide a means of storing data in a more meaningful way

Key  :   value    Pairs

______eg
user = {
    "username": "tombombadil",
    "first_name": "Tom",
    "last_name": "Bombadil",
    "age": 100
}

print(user)
print(user['age'])
user['home'] = 'Withywindle, Middle-Earth'
user['age'] = 99
print(user)
del user['home'] 
print(user)
print(list(user))
print(sorted(user))
print(user)
print('username' in user)
CONSOLE
{'username': 'tombombadil', 'first_name': 'Tom', 'last_name': 'Bombadil', 'age': 100}
100
{'username': 'tombombadil', 'first_name': 'Tom', 'last_name': 'Bombadil', 'age': 99, 'home': 'Withywindle, Middle-Earth'}
{'username': 'tombombadil', 'first_name': 'Tom', 'last_name': 'Bombadil', 'age': 99}
['username', 'first_name', 'last_name', 'age']
['age', 'first_name', 'last_name', 'username']
{'username': 'tombombadil', 'first_name': 'Tom', 'last_name': 'Bombadil', 'age': 99}
True

_______________________________________________challenge
# Declare a variable named spaceship and assign it the value of a dictionary
spaceship = {
    "name": "Red Dwarf",
    "type": "Mining vessel",
    "owner": "Jupiter Mining Corporation",
    "captain": "Frank Hollister"
}

# Print the value of the spaceship object to the terminal
print(spaceship)

CONSOLE
{'name': 'Red Dwarf', 'type': 'Mining vessel', 'owner': 'Jupiter Mining Corporation', 'captain': 'Frank Hollister'}


______________________________________________________________Getting and Setting Dictionaries
getting or setting dictionary values
get a key:value pair or a new valuewith a [square bracket notation or method]

______eg
keys = ['username', 'first_name', 'last_name', 'age']
default_value = ''
user = dict.fromkeys(keys, default_value)
print(user)
user['username'] = 'tombombadil'
user['first_name'] = 'Tom'
user['last_name'] = 'Bombadil'
user['age'] = 100
print(user)
print(user['age'])
print(user.get('home', "doesn't exist"))
user['home'] = 'Withywindle, Middle-Earth'
user['age'] = 99
print(user)
del user['home'] 
print(user)
print(list(user.keys()))
print(list(user.values()))
print(user)
CONSOLE
{'username': '', 'first_name': '', 'last_name': '', 'age': ''}
{'username': 'tombombadil', 'first_name': 'Tom', 'last_name': 'Bombadil', 'age': 100}
100
doesn't exist
{'username': 'tombombadil', 'first_name': 'Tom', 'last_name': 'Bombadil', 'age': 99, 'home': 'Withywindle, Middle-Earth'}
{'username': 'tombombadil', 'first_name': 'Tom', 'last_name': 'Bombadil', 'age': 99}
['username', 'first_name', 'last_name', 'age']
['tombombadil', 'Tom', 'Bombadil', 99]
{'username': 'tombombadil', 'first_name': 'Tom', 'last_name': 'Bombadil', 'age': 99}


_______________________________________________challenge
data = {
    "first_name": "Arthur",
    "last_name": "Dent",
    "species": "Human"
}

# add your code here
# Using the key "first_name", pull the value from the data dictionary and assign it to a variable called name
name = data["first_name"]

# Print the value of name to the terminal
print("Name:", name)

# Using the key "species", pull the value from the data dictionary and assign it to a variable called species
species = data["species"]

# Print the value of species to the terminal
print("Species:", species)

# Insert a new key "age" with a value of 42 into the data dictionary
data["age"] = 42

# Print the updated data dictionary to the terminal

# this will print the data to the terminal
print(data)
CONSOLE
Name: Arthur
Species: Human
{'first_name': 'Arthur', 'last_name': 'Dent', 'species': 'Human', 'age': 42}



______________________________________________________________Dictionary methods

Method	                           Description
clear()	                      Removes all the elements from the dictionary
copy()	                      Returns a copy of the dictionary
fromkeys()	                    Returns a new dictionary with the specified keys and value
get(keyname, value)	          Returns the value of the specified keyname. Used in the previous unit. Returns default None if the keyname doesn't exist unless you override this default with a optional value.
items()	                     Returns a list containing a tuple for each key:value pair
keys()	                       Returns a list containing the dictionary's keys. Used in the previous unit.
pop()	                      Removes the element with the specified key
popitem()	                 Removes the last inserted key:value pair
setdefault()	             Returns the value of the specified key. If the key does not exist: insert the key, with the specified value
update()	                  Updates the dictionary with the specified key:value pairs
values()	                  Returns a list of all the values in the dictionary. Used in the previous unit.

______eg
user = {
    "username": "tombombadil",
    "first_name": "Tom",
    "last_name": "Bombadil",
    "age": 100
}

print(user)
print(user.items())
print(user.get('age', 0))
user.update({'home': 'Withywindle, Middle-Earth'})
print(user)
print(user.popitem())
print(user)
user.clear()
print(user)
CONSOLE
{'username': 'tombombadil', 'first_name': 'Tom', 'last_name': 'Bombadil', 'age': 100}
dict_items([('username', 'tombombadil'), ('first_name', 'Tom'), ('last_name', 'Bombadil'), ('age', 100)])
100
{'username': 'tombombadil', 'first_name': 'Tom', 'last_name': 'Bombadil', 'age': 100, 'home': 'Withywindle, Middle-Earth'}
('home', 'Withywindle, Middle-Earth')
{'username': 'tombombadil', 'first_name': 'Tom', 'last_name': 'Bombadil', 'age': 100}
{}

_______________________________________________challenge
challenger = {
	"name": "Katniss Everdeen",
	"age": 16,
	"district": 12,
	"weapon": "Bow and Arrow", 
	"status": "Victor"
}

# add your code here
# Use the update() method to add a new key-value pair to the challenger dictionary
challenger.update({"occupation": "Hunter"})

# Use the get() method to get the value stored at the "occupation" key in the challenger dictionary
occupation = challenger.get("occupation")

# Print the value of the occupation variable to the terminal
print("Occupation:", occupation)

# Use the update() method to update the value stored at the "age" key to 17
challenger.update({"age": 17})

# Use the pop() method to remove the key-value pair for "status" from the challenger dictionary
challenger.pop("status")

# Print the updated challenger dictionary to the terminal
print(challenger)
CONSOLE
Occupation: Hunter
{'name': 'Katniss Everdeen', 'age': 17, 'district': 12, 'weapon': 'Bow and Arrow', 'occupation': 'Hunter'}
{'name': 'Katniss Everdeen', 'age': 17, 'district': 12, 'weapon': 'Bow and Arrow', 'occupation': 'Hunter'}


______________________________________________________________Sets
an unordered collection with no duplicates
used with curly brackets and commas to separate iteems

set()     ()     can also is 'in' keyword with sets

good for forbiding duplicates
can use dictionary methods like add()   update()     discard()     remove()     pop()

______eg
breakfast = {'bacon', 'egg', 'spam', 'spam', 'spam', 'spam', 'spam'}
print(breakfast)
print('egg' in breakfast)
breakfast.add('sausage')
print(breakfast)
breakfast.update(['Lobster Thermidor', 'truffle pate', 'crevettes', 'shallots','aubergines'])
print(breakfast)
breakfast.discard('aubergines')
print(breakfast)
CONSOLE
{'egg', 'spam', 'bacon'}
True
{'egg', 'sausage', 'spam', 'bacon'}
{'truffle pate', 'aubergines', 'spam', 'egg', 'crevettes', 'sausage', 'Lobster Thermidor', 'shallots', 'bacon'}
{'truffle pate', 'spam', 'egg', 'crevettes', 'sausage', 'Lobster Thermidor', 'shallots', 'bacon'}

______eg- set operators
hello = set("Hello")
world = set("World")
print(f"The unique letters in hello are: {hello}")
print(f"The letters in hello or world or both are: {hello|world}") # | is the symbol for union
print(f"The letters in both hello and world are: {hello&world}") # & is the symbol for intersection
print(f"The letters in hello but not world are: {hello-world}") # - is the symbol for difference
print(f"The letters in hello and world but not both are: {hello^world}") # ^ is the symbol for symmetric difference
CONSOLE
The unique letters in hello are: {'H', 'o', 'e', 'l'}
The letters in hello or world or both are: {'d', 'W', 'H', 'e', 'r', 'o', 'l'}
The letters in both hello and world are: {'o', 'l'}
The letters in hello but not world are: {'H', 'e'}
The letters in hello and world but not both are: {'d', 'e', 'W', 'H', 'r'}

______________________challenge
product_list = ['hammer', 'saw', 'nails', 'wood', 'screws', 'paint', 'brushes', 'light bulbs']
products_bought = {'nails', 'screws', 'hammer', 'wood', 'saw', 'hammer', 'saw', 'nails', 'nails', 'screws', 'hammer'}

# add your code here
# Use the add() method to add the string "light bulbs" to the products_bought set
products_bought.add("light bulbs")

# Use the update() method to add a list of three more products that have been bought to the products_bought set
products_bought.update(['wood', 'screws', 'saw'])

# Create a variable has_nails and assign it an expression that checks if "nails" is in the products_bought set
has_nails = "nails" in products_bought

# Create a variable has_paint and assign it an expression that checks if "paint" is in the products_bought set
has_paint = "paint" in products_bought

# Create a variable named unsold_items. Assign it an expression that finds the difference between product_list and products_bought
unsold_items = set(product_list) - products_bought

# Print out the variables
print("Has nails:", has_nails)
print("Has paint:", has_paint)
print("Unsold items:", unsold_items)
CONSOLE
Console:
Has nails: True
Has paint: False
Unsold items: {'paint', 'brushes'}


___________________________________________________WORKING WITH PYTHON DATA STRUCTURES

_____________________________________________Iterating Python Data STRUCTURES

using indexing and getters
with    in for simple data structures   and    .items()  for dictionaries

___eg dictionary

user = {
    "username": "tombombadil",
    "first_name": "Tom",
    "last_name": "Bombadil",
    "age": 100
}

for key, value in user.items():
    print(f"Key: {key}")
    print(f"Value: {value}")
    print("------------------")

    CONSOLE
    Key: username
Value: tombombadil
------------------
Key: first_name
Value: Tom
------------------
Key: last_name
Value: Bombadil
------------------
Key: age
Value: 100
------------------

___eg set
# Create a set
directions = set(['north', 'south', 'east', 'west'])

# Print its members
for direction in directions:
    print(direction)

# Add an item to the set:
directions.add('northwest')

print()
# Print the members again
# Notice the order cannot be relied upon!
for direction in directions:
    print(direction)

CONSOLE
north
south
east
west
east
northwest
south
north
west

________________________________challenge
data = {
    "first_name": "brian",
    "last_name": "johnson",
    "occupation": "student"
}

scores = [6, 9, 8, 7, 8, 9]

# Loop through each key and value in the data dictionary items
for key, value in data.items():
    # Check if the value is NOT equal to "student"
    if value != "student":
        # Update the string values to capitalize the first letter
        data[key] = value.capitalize()

# Print the updated data dictionary to the console
print(data)

# Loop through the scores list using range() and len()
for i in range(len(scores)):
    # Increase each value in the scores list by 1
    scores[i] += 1

# Print the updated scores list to the console
print(scores)

CONSOLE
{'first_name': 'Brian', 'last_name': 'Johnson', 'occupation': 'student'}
[7, 10, 9, 8, 9, 10]



____________________________________________List comprehensions
a concise way to create a list
generates a list
by using square brackets with an expression and a for cleuse

numbers = []
for x in range(10):
    numbers.append(x)
---becomes---

numbers = [x for x in range(10)]

___eg
# 1. [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print([i for i in range(10)])               [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 2. [0, 2, 4, 6, 8, 10]
print([i for i in range(0,11,2)])            [0, 2, 4, 6, 8, 10]

# 3. [0, 1, 4, 9, 16, 25, 36, 49]
print([x**2 for x in range(0,8)])             [0, 1, 4, 9, 16, 25, 36, 49]

# 4. [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]
print([((i,(i+1))) for i in range(5)])             [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]

# 5. ['woohoo', 'woohoo', 'woohoo', 'woohoo', 'woohoo', 'woohoo', 'woohoo', 'woohoo']
print(['woohoo' for i in range(7)])                 ['woohoo', 'woohoo', 'woohoo', 'woohoo', 'woohoo', 'woohoo', 'woohoo']

# 6. ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
hw = 'hello world'
print([i for i in hw])                                ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']

# 7. [('A', 'D'), ('A', 'E'), ('A', 'F'), ('B', 'D'), ('B', 'E'), ('B', 'F'), ('C', 'D'), ('C', 'E'), ('C', 'F')]
ab = 'ABCDEF'
print([(ab[i],ab[j]) for i in range(0,3) for j in range(3,6)])
                            [('A', 'D'), ('A', 'E'), ('A', 'F'), ('B', 'D'), ('B', 'E'), ('B', 'F'), ('C', 'D'), ('C', 'E'), ('C', 'F')]


__________________________challenge
# Using list comprehension to add each letter from the string "Marvin" to a list
letters = [letter for letter in "Marvin"]

# Print the value of the letters list to the terminal
print("Letters:", letters)

# Define a variable named numbers and assign it a list of numbers from 1 to 10
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Using list comprehension to extract the even numbers from the numbers list
evens = [number for number in numbers if number % 2 == 0]

# Print the value of the evens list to the terminal
print("Evens:", evens)


____________________________________________Dictionaries comprehensions

a concise way to create a dictionary
using curly braces with an expression and a for clause with an key:value

squares = {}
for x in (2, 4, 6):
    squares[x] = x**2

    becomes

squares = {x: x**2 for x in (2, 4, 6)}

______eg
# 1. {'apple': 5, 'mango': 5, 'banana': 6, 'cherry': 6}
fruits = ['apple', 'mango', 'banana','cherry']
print({f:len(f) for f in fruits})
           {'apple': 5, 'mango': 5, 'banana': 6, 'cherry': 6}

# 2. {0: '', 1: '*', 2: '**', 3: '***', 4: '****'}
print({i:(i*'*') for i in range(0,5)})
            {0: '', 1: '*', 2: '**', 3: '***', 4: '****'}

# 3. {0: True, 1: False, 2: True, 3: False, 4: True, 5: False, 6: True, 7: False, 8: True, 9: False}
print({i:(True if i%2==0 else False) for i in range(10)})
              {0: True, 1: False, 2: True, 3: False, 4: True, 5: False, 6: True, 7: False, 8: True, 9: False}

# 4. {(0, 0): True, (0, 1): False, (0, 2): False, (0, 3): False, (1, 0): False, (1, 1): True, (1, 2): False,
# (1, 3): False, (2, 0): False, (2, 1): False, (2, 2): True, (2, 3): False, (3, 0): False, (3, 1): False,
# (3, 2): False, (3, 3): True}
print({(i,j): (True if i==j else False) for i in range(4) for j in range(4)})
               {(0, 0): True, (0, 1): False, (0, 2): False, (0, 3): False, (1, 0): False, (1, 1): True, (1, 2): False, (1, 3): False, (2, 0): False, (2, 1): False, (2, 2): True, (2, 3): False, (3, 0): False, (3, 1): False, (3, 2): False, (3, 3): True}


________________________________challenge
cards = ['king', 'queen', 'jack', 'ace']

# Using dictionary comprehension to create cards_dict
cards_dict = {card: card.upper() for card in cards}

# Print the value of the cards_dict variable to the terminal
print(cards_dict)

CONSOLE
{'king': 'KING', 'queen': 'QUEEN', 'jack': 'JACK', 'ace': 'ACE'}



_________________________________________Nested data structures

when you have a data structure within a data structure

___eg
matrix = [
    [11, 12, 13, 14],
    [15, 16, 17, 18],
    [19, 20, 21, 22],
]

print([[row[i] for row in matrix] for i in range(4)])

CONSOLE
[[11, 15, 19], [12, 16, 20], [13, 17, 21], [14, 18, 22]]


___eg
payroll = {'emp1': {'name': 'Precious', 'job': 'Mgr', 'Wage': 50000},
     'emp2': {'name': 'Kim', 'job': 'Dev', 'Wage': 60000},
     'emp3': {'name': 'Sam', 'job': 'Dev', 'Wage': 70000}}

print(payroll)

print(payroll['emp1']['name'])
print(payroll['emp1'].get('salary'))
print(payroll['emp1'].get('Wage'))
payroll['emp4'] = {'name': 'Max', 'job': 'Admin', 'Wage': 30000}
print(payroll)
del payroll['emp3']

for id, info in payroll.items():
    print(f'\nEmployee ID: {id}')
    for key in info:
        print(f'{key} : {info[key]}')

CONSOLE
{'emp1': {'name': 'Precious', 'job': 'Mgr', 'Wage': 50000}, 'emp2': {'name': 'Kim', 'job': 'Dev', 'Wage': 60000}, 'emp3': {'name': 'Sam', 'job': 'Dev', 'Wage': 70000}}
Precious
None
50000
{'emp1': {'name': 'Precious', 'job': 'Mgr', 'Wage': 50000}, 'emp2': {'name': 'Kim', 'job': 'Dev', 'Wage': 60000}, 'emp3': {'name': 'Sam', 'job': 'Dev', 'Wage': 70000}, 'emp4': {'name': 'Max', 'job': 'Admin', 'Wage': 30000}}
Employee ID: emp1
name : Precious
job : Mgr
Wage : 50000
Employee ID: emp2
name : Kim
job : Dev
Wage : 60000
Employee ID: emp4
name : Max
job : Admin
Wage : 30000

______________________challenge
# Declare the student_data variable and assign it a list containing two dictionaries
student_data = [
    {
        "name": "John Smith",
        "email": "john@gmail.com",
        "subjects": ["Math", "Psychology", "Physics", "Chemistry", "Biology"]
    },
    {
        "name": "Mary Jones",
        "email": "mary@gmail.com",
        "subjects": ["Fine Art", "Music", "Biology", "Geography", "Politics"]
    }
]

# Print the student_data to the terminal
print(student_data)

CONSOLE
[{'name': 'John Smith', 'email': 'john@gmail.com', 'subjects': ['Math', 'Psychology', 'Physics', 'Chemistry', 'Biology']}, {'name': 'Mary Jones', 'email': 'mary@gmail.com', 'subjects': ['Fine Art', 'Music', 'Biology', 'Geography', 'Politics']}]





---------------------------------------PYTHON BEST PRACTICES--------------

_______________________________Variable naming conventions
best practice for variable names
standardises code
by following PEP8 rules

lowercase with underscores dealing with multiple words with spaces
name explains purpose

___eg
count = 0
first_name = Brian

_______________________________Function naming conventions

same as above
descriptive


_______________________________class naming conventions

name needs to give the reader an indication as to its purpose
___eg
class ComplexNumber:
def __init__(self, realpart, imagpart):
    self.r = realpart
    self.i = imagpart


_________________________________________comments

# single line comments
""
multiple
lines
""

___eg
from random import randint

# This is a one-line comment

"""
This is  multi-line comment.

We can spread this across as many lines as we need to
and it won't impact our computer program at all!!!
"""

def lottery_generator():
    """
    Appends ten random numbers to an empty list
    Returns the list
    """
    numbers = [] # Empty list to hold the numbers
    for number in range(0, 10):
		# randint() generates random integers
        numbers.append(randint(1, 50))
    return numbers

print(f"This weeks winning lottery numbers are {lottery_generator()}")

CONSOLE

This weeks winning lottery numbers are [4, 38, 2, 24, 12, 47, 18, 16, 8, 9]


_________________________________________indentation

number of spaces code is indented by
defines code blocks
use 4 spaces per indentation level

___eg
# Correct:

# It is aligned with the opening delimiter, e.g. the opening parentheses.
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# Add four spaces (an extra level of indentation) to distinguish arguments from the rest.
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)

# Hanging indents should add a level.
foo = long_function_name(
    var_one, var_two,
    var_three, var_four)

___________________________________reserved keywords

words with a specific purpose
they perform a specific function or actions
these words cannot be used as variable or function names

import keyword

print(keyword.kwlist)

['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 
'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 
'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 
'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']



_________________________________________________PYTHON FUNCTIONS AND OBJECT ORIRNTED Programming

___________________________________________FUNCTIONS

___________________________________Defining functions
allow us to group pieces of logic that will perform a particular task

can use comments in code to explain the function for otherwise

______eg
def print_message():
    print("Hello World!")

print_message()
CONSOLE
Hello World!

________________Lamda function
a small anonymous function- can take a number of arguments but only one expression

___eg
add = lambda a, b : a + b
print(add(5, 12))
CONSOLE
17


___________________________________Calling functions

executing the code
calls the functions with arguments if required
by using the functiion name with parenthesis as a suffix

can pass information into the function as arguments inside the parentheses separated by commas
a parameter is the variable listed in the parenthesis when the function is defined
the argument is the value you pass into the function parentheses when it is called
You have to supply the same number of arguments as there are parameters. 
A function can be called by another function or even by itself.

______eg
# 2. This function runs for the name and age function calls
def get_user_input(prompt):
    return input(prompt)

# 4. This function runs twice
def print_out_to_console(value_to_be_printed):
    print(value_to_be_printed)

# 1. name and age are the first two function calls to run sequentially
name = get_user_input("Input your name:")
age = get_user_input("Input your age:")

# 3. Then function calls run sequentially
print_out_to_console(f"Your name is {name}")
print_out_to_console(f"You are {age} years old")

______________________challenge

# Define the function named print_hello_world
def print_hello_world():
    # Inside the function, print the string "Hello World!"
    print("Hello World!")

# Outside of the function, call the print_hello_world function
print_hello_world()

CONSOLE
Hello World!


_____________________________________________________________Taking Parameters & Returning Results
parameters and arguments
allows us to provide functions with data and context
in the event that we might need our functions to perform actions on specific pieces of data, we would 
use arguments to pass that part of the data into the function

purpose of using functions is to have usable code

can use parameters to provide a function with data we want it (the function) to use

______eg
def print_message(name):
    print(f"Hello {name}")

username = input("What's your name? ")
print_message(username)

can also use optional parametetrs- these allow us to provide values to a function with some value in case 
                                   they are not provided when the function is invoked

                                   use the assignment operator to set a value to the parameter when we are
                                    defining our function

___eg
def print_message(name="World"):
    return f"Hello {name}"

username = input("What's your name? ")
print(print_message())
print(print_message(username))
CONSOLE
What's your name? Alex
Hello World
Hello Alex


_____________________________________________________________Writing simple Functions in Python


- build a function that takes 2 numbers and returns the sum of the two numbers

1. define the function with the def keyword, then the function name followed by the function's parentheses
   and a colon

def add_two_numbers():
    print("function running")

add_two_numbers()  //calls function      //returns "function running"


2. pass function 2 numbers to add together
         - name the function's parameters inside the function's parentheses 
                 
                 def add_two_numbers(num1, num2):
    
    then, inorder to set the values for those parameters- define them where the function is called
                 
                 add_two_numbers(2, 3)

        check by printing values to the console

                 print(num1, num2)

3. add values to the function
        #add values to function
def add_two_numbers(num1, num2):
    print(num1, num2)

add_two_numbers(2, 3)


4. add the two numbers together with sum and check
        #add the two numbers together 
def add_two_numbers(num1, num2):
    sum = num1 + num2
    print(sum)

add_two_numbers(2, 3)


5. return the sum value from the function back to where it was called
       swap the print() statements for a reture() statement

def add_two_numbers(num1, num2):
    sum = num1 + num2
    return sum

add_two_numbers(2, 3)


6. give the value a place to go  eg- result

def add_two_numbers(num1, num2):
    sum = num1 + num2
    return sum

result = add_two_numbers(10, 32)
print(result)                    //result 42

______eg
Add 3 numbers and multiply them together to get a result

def multiply_three_numbers(num1, num2, num3):
    product = num1 * num2 * num3
    return product

result = multiply_three_numbers(2, 10, 3)
print(result) 
             #result 60


takes one number and returns its value squared (the number times itself)

def num_squared(num1):
    product = num1 * num1
    return product

result = num_squared(2)
print(result) 
             #result 4

that takes 2 numbers, and returns the value of the first number divided by the second number

def num_divided(num1, num2):
    dividend = num1 / num2
    return dividend

result = num_divided(100, 2)
print(result) 
             #result 50

_______________________________________________challenge
# Define the function named add_numbers that takes two parameters: nums_tuple, min_value
def add_numbers(nums_tuple, min_value):
    # The function returns the sum of all values in nums_tuple that are greater or equal to min_value
    return sum(num for num in nums_tuple if num >= min_value)

# Outside of the function
# Create a variable named total and assign it the return value from calling add_numbers function
total = add_numbers((21, 4, 7, 19, 1), 15)

# Print the total
print(total)
              -result  40



__________________________________________________________________Splat! *args & **kwargs
Iterable objects
allows youto pass many arguments
using   *args     and   **kwargs    syntax 

In a function, you can list the parameters separated with commas. 
n elementary function is one that takes parameters a, b and adds their argument values together. This 
function is then reusable as you can add any two numbers together

The purpose of *args is to allow you to pass in a varied number of positional arguments.
The iterable object *args can be renamed to any other name as long as it is preceded by the unpacking 
operator *
Rather than a list, the *args operator is a tuple so is immutable and needs to be unpacked to use the 
values.

The **kwargs object behaves very similarly but rather than a tuple is a dictionary.
you can change the name as long as the ** unpacking operator precedes it
Where you would use **kwargs over *args is when you have a keyword or named arguments.

______eg
def addition(a, b):
    return a + b

print(addition(2,2))

def add_integers(list_integers):
	total = 0
	for x in list_integers:
		total += x
	return total

list_integers = [1, 2, 3, 4]
print(add_integers(list_integers))

def add_many_integers(*integers):
	# Rename *args to something suitable
	total = 0
	for x in integers:
		# As it is a tuple you can use the in keyword to iterate 
		total += x
	return total

print(add_many_integers(1,2,3,4,5,6,7,8,9))

def concatenate_words(**words):
	result = ""
	# As **kwargs is a dict you need to iterate over .values()
	for arg in words.values():
		result += arg
		result += " "
	return result

print(concatenate_words(a='This', b="is", c="a", d="useful", e="feature"))

CONSOLE
4
10
45
This is a useful feature 

_______________________________________________challenge
# Define the make_string function
def make_string(*strings):
    # Join all the values in strings tuple with a space and return the result
    return ' '.join(strings)

# Call the make_string function
# Declare a variable named my_string
my_string = make_string("Alderaan", "Coruscant", "Dagobah", "Endor", "Hoth")

# Print the value of the my_string variable to the terminal
print(my_string)

# Define the get_age function
def get_age(**data):
    # Return the value of the age key if it exists, otherwise return "no age provided"
    return data.get('age', "no age provided")

# Call the get_age function
# Declare a variable named pats_age
pats_age = get_age(name="pat", level=4, age=33, occupation="postman")

# Print the value of the pats_age variable to the terminal
print(pats_age)

CONSOLE
Alderaan Coruscant Dagobah Endor Hoth
33



_______________________________________________________________________________scope- Local vs Global variables
refers to the visibility of variables
defines which parts of your program can see or use particular variables
by defining variables inside or outside functions

Broadest scope-
      Built-in--variables that come with python- no need to declare or import

      Global- variables that are declared but not within functions- available to use anywhere within  the program

      local scope--a variable inside a function and so, only available for use within that function

      enclosing scope- neither local nor global- found in nested functions

If a variable is needed throughout the program, then declaring it at the top outside any functions will make it global.
However, declaring variables as global when they are not required everywhere in a program is bad practice. Consider local scope instead.

Declaring your variables inside the functions in which they will be used is good practice. However, you will run into 
issues with the local scope if you need to use a variable in nested functions. In Python, a variable is considered local 
by default.


_________________________________________________the 'global' keyword

keyword to override the default variable scope
scope is local by default so can specify otherwise with use of keyword
use global   or    nonlocal   keywords when defining variables

in python, variables are treated as local unless otherwise declared

use keywords to sort it out unambiguously

___eg
example below, you will see that the can_access variable remains False in the global scope despite being reassigned to 
True in the update_access function if age greater than or equal to 18 is input.

can_access = False
	
def update_access():
    age = int(input('Enter your age: '))
    if age >= 18:
        # We may think this is updating the global variable can_access, but its not as it is now considered a local variable
        can_access = True
        return('You are old enough enter')
    else:
        return('You are too young, you may not enter');

update_access()

print(can_access) # will still print out False

In this second example you will see as you step through that if you input an age greater than or equal to 18 the global 
variable can_access changes to True even in the global scope. This is because the global keyword has been used.

can_access = False
	
def update_access():
    global can_access
    age = int(input('Enter your age: '))
    if age >= 18:
        # The global keyword is used
        can_access = True
        return('You are old enough to enter')
    else:
        return('You are too young, you may not enter');

update_access()

print(can_access) # will now print True if an age >= 18 is entered

________________________________________-challenge
test_passed = False
answer = "friend"

def speak_friend_and_enter():
    global test_passed        #added line to make test_passed global and change outcome from false to true
    if answer == "friend":
        test_passed = True
        
speak_friend_and_enter()
print(test_passed)



_________________________________________________________________________The   nonlocal    keyword

keywords to override the default variable scope
scope is local by default so you can specify otherwise with a keyword
use   nonlocal     keywords when defining variables

______eg
In the nested function example below you will see that line 4 does not work. The variable my_age is local to the which_scope
 function not the inner_scope one

def which_scope():
    my_age = 49 # local variable my_age
    def inner_scope():
        my_age += 1 # Issue when we try to run this line.
        print(my_age)
    inner_scope()

which_scope()                  #creates an error- UnboundLocalError: local variable 'my_age' referenced before assignment

change to this (using the nonlocal keyword)

def which_scope():
    my_age = 49 # local variable my_age
    def inner_scope():
        nonlocal my_age # No longer an issue because of this
        my_age += 1
        print(my_age)
    inner_scope()

which_scope()      #returns 50

___________________________________________________challenge

def outer_function():
    age = 10
    def become_adult():
        nonlocal age       #added line
        age = age + 11
        
    become_adult()
    return age

result = outer_function()
print(result)
                            # returns 21

___________________________________________________________________Passing functions around
a function is an object
allows you to pass a function around
avoid repetition by reusing functions

a function object can be referred to in the same way as a string object
you can assign a function to a variable or even store it in a data structure
a function can be passed into another function or even itself

___eg
def print_arguments( **args ):
    """Prints the arguments"""
    print(f'The arguments are {args}')

def pass_function(function_name, **args):
    """Takes a function as an argument
    Passes the argument 'l' to the function passed in 
    """
    print("This function takes another function as an argument")
    function_name(f=args['l'])

pass_function(print_arguments, l='spam')

# returns- This function takes another function as an argument
The arguments are {'f': 'spam'}


______________________________________________________________Decorators

a software design pattern
alters functions
by wrapping the function in the decorator

a way of adding new functionality to an existing function without modifying its structure
 useful as you do not need to create new functionality in your code if a decorator already exists for that purpose
A decorator is said to wrap a function to modify its behaviour
Python has something called the “pie syntax” to make decorator use simpler.
The @ symbol is used to prefix the decorator name.

___eg
Here is a very simple decorator. It modifies the function say_hello by printing a string before it is called and after it 
is called. The decorator is modifying the behaviour of the function. It wraps the function and extends the behaviour of 
the wrapped function without modifying the function permanently.

def my_decorator(func):
    def wrapper():
        print("The function has not been called yet. Let's call it.")
        func()
        print("The function was called and has returned a result.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello, world!")
    
say_hello()

______eg

def define_units(unit):
    """Define the units"""
    def decorator_define_units(func):
        func.unit = unit
        return func
    return decorator_define_units

@define_units('m^2')
def area(length, width):
    """Calculate area of rectangle or parallelogram"""
    return length * width

# The unit defined in the decorator can be used with dot notation
# In this case the function area units can be used as area.unit
print(f'The area is {area(3,5)}{area.unit}')                        # returns 'The area is 15m^2

_________________________________________________-challenge

# Define the decorator
def add_author(func):
    """
    Decorator to add string with author information
    to print after decorated function runs
    """
    def wrapper(*args):
        r = func(*args)
        return f"{r}\nBy Code Institute"
    return wrapper

# Define the function and apply the decorator
@add_author
def print_article_title(title):
    return f"Article Title: {title}"

# Outside the function
# Create a variable named result and assign it the return value from calling the print_article_title function
result = print_article_title("Python Decorators")

# Print the result
print(result)                     

#returns 
Article Title: Python Decorators
By Code Institute

_________________________________________________-challenge
#functions challenge
numbers = [12, 45, 60, 87, 999, 200, 84, 42, 87, 77, 2, 3, 77, 99, 20]
# 1. define/ name the function
#3.pass the function the list of numbers- tell function to expect it
def get_odd_nums(list_of_nums):
    #5. create empty list variable to add numbers into
    new_list = []
    for num in list_of_nums:#6. access each num in list to check which ones are odd (use a for loop)
        if num % 2 != 0:
            new_list.append(num)
    return new_list
#2. call the function with call statement
#4. pass the list into where t is called
result = get_odd_nums(numbers)
print(result)         #[45, 87, 999, 87, 77, 3, 77, 99]
_______________________________________________________________________________________________PYTHON CLASSES

____________________________________________________________________Defining Classes within Python

Python os an object-oriented-language- supports classes
known as a mixed-paradigm language- can use either a functional or object oriented style

classes a good way of combining data and methods and are useful when dealing with hierarchies.
generally used to model more complex data types which can’t be modelled using Python’s built-in data structures such as 
ists and dicts

define a class by using the class keyword followed by the name
a class does not do anything until it is executed.
Scope also applies to classes so global and nonlocal scope have to be taken into consideration. 
A class name should start with a capital letter and should have a docstring
Classes can contain functions and other statements.
eg
class HelloWorld:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'Hello, world!'

____________________________________________________________________the  __init__() Method
an initializer method
initializes the properties of the isinstance
use with the dunder init syntax

a function within a class is known as a method
 A particular type of method that runs when an instance of the class is created is an initializer. 
 he __init__ method is known as a dunder, double-underscore or magic method, and these tend to be used on classes mainly.
 They use double underscores so as not to conflict with your own defined classes.

An __init__() method on its own would simply create an empty class object
However, an __init__() method can take arguments.
One of the advantages of object-orientated programming is the ability to model the real world in code.
    If you were writing software to use in a car factory or dealership, you could use a class to create an object Car that 
    has the same properties and attributes as a real car.

______eg

we have initialized a Car object with attributes 'Green', 'Ford', 'Mustang' and 'Gasoline'. Note the use of the self 
keyword.

class Car:
	def __init__(self, color, make, model, fueltype):
		self.color = color
		self.make = make
		self.model = model
		self.fueltype = fueltype

bullitt = Car('Green', 'Ford', 'Mustang', 'Gasoline')

___________________________________________________challenge

class Customer:
    """
    Creates an instance of Customer
    """
    
    def __init__(self, fname, lname, email, phone):
        self.fname = fname
        self.lname = lname
        self.email = email
        self.phone = phone

# Testing the class definition
customer1 = Customer("John", "Doe", "john.doe@example.com", "123-456-7890")
print(f"First Name: {customer1.fname}")
print(f"Last Name: {customer1.lname}")
print(f"Email: {customer1.email}")
print(f"Phone: {customer1.phone}")

#returns CONSOLE
First Name: John
Last Name: Doe
Email: john.doe@example.com
Phone: 123-456-7890

____________________________________________________________________the  self keyword
a keyword
associates functions and properties with a class
use it in the constructors

The self keyword associates functions and properties with a class. 
It also holds references to data and behaviour of particular instances of a class. 
It’s customary to use self to refer to the class instance, but in fact, any variable could be used.
It must be the first parameter of any function in the class.
Python simply uses self to state to what instance to assign an instance attribute
In the previous unit, we created an object bullitt with color of Green. The self keyword is used to confirm that the 
argument "Green" for the object instance bullitt is a reference to the color attribute of the class Car.

______eg
This example of a class Bird has properties of kind and call. A function (or method) to describe the bird is included in 
the class.

class Bird:
   """
   Bird class
   """
   def __init__(self, kind, call):
      #properties
       self.kind = kind
       self.call = call

   #behaviour
   def description(self):
       """
       describe the bird
       """
       return f"A {self.kind} goes {self.call}" 
       
owl = Bird('Owl', 'Twit Twoo!')
print(owl.description())

____________________________________________________challenge   
class OrderItem:
    """
    Creates an instance of OrderItem
    """
    
    def __init__(self, item, price, quantity):
        self.item = item
        self.price = price
        self.quantity = quantity

    def description(self):
        return f"{self.quantity} x {self.item} at ${self.price} each"

# Testing the class definition
order_item = OrderItem("bowtie", 10, 3)
print(order_item.description())  # Output: 3 x bowtie at $10 each


___________________________________________________________________________Creating class instances

an individual object of a class
it is a live instance of the class in memory with values
use with a consructor

You can create multiple instances of a class.
An instance is an individual object of the class in memory. It exists live in RAM until the point it is removed.

______eg
Let's return to the Bird class. When you create an instance of the class, it is the initializer code that runs. 
This is the __init__ method. This method assigns the values to the object properties. The self keyword is a reference to 
the current instance of the class and is used to access variables that belong to the class. To create an instance of the 
class, you need to provide the same quantity of values as there are properties (in this case two). Once you have an 
instance of that class, you can access the variables and methods using the dot notation.

owl = Bird('Owl', 'Twit Twoo!')
owl.call
owl.description()

The dot notation can also be used to modify the properties of objects with the use of the assignment operator.
The del keyword can be used to delete a property or an object.


___eg
class Bird:
   """
   Bird class
   """
   def __init__(self, kind, call):
      #properties
       self.kind = kind
       self.call = call

   #behaviour
   def description(self):
       """
       describe the bird
       """
       return f"A {self.kind} goes {self.call}" 
  
   def bird_call(self):
       print(self.call.upper())

owl = Bird('Owl', 'Twit Twoo!')
print(owl.call)
print(owl.description())
crow = Bird('Crow', 'Caaaw!')
print(crow.description())
owl.call = 'screech'
print(owl.description())
del owl.call
print(owl.description())

-----------returns CONSOLE
Twit Twoo!
A Owl goes Twit Twoo!
A Crow goes Caaaw!
A Owl goes screech
AttributeError: 'Bird' object has no attribute 'call'

________________________________________________________-challenge

class User():
    """
    Creates an instance of User
    """
    def __init__(self, username, email, subscribed):
        self.username = username
        self.email = email
        self.subscribed = subscribed
    
    def description(self):
        """
        Describes the instance of User
        """
        return f"user: {self.username}, email: {self.email}, subscribed: {self.subscribed}"


# write your code here
# Create an instance of the User class
user_one = User("arnold", "arnold@email.com", True)

# Print the email attribute of the user_one object
print(user_one.email)

# Update the email attribute of the user_one object
user_one.email = "murphy@email.com"

# Print the description of the user_one object
print(user_one.description())

CONSOLE
arnold@email.com
user: arnold, email: murphy@email.com, subscribed: True

__________________________________________________________________________Class properties and sttributes

data within  a class
either fixed value or definable
use by using arguments as you initiate an object

A class can contain data
If you create a Python variable within the class, it is known as a class attribute.
As it is created outside the constructor function, it is shared between all objects of this class. 

However, if you create a Python variable within the constructor function, it is known as an instance attribute.
An instance attribute is only accessible from the scope of an object instantiated from the class.

When we access these attributes from the class or from the object, they are referred to as properties.
 class attribute can be accessed as a class property or an instance property. 
 If you try and access an instance attribute as a class property, then you will raise an AttributeError.

______eg
In the runnable example, there is both a class attribute of definition and two instance attributes of kind and call. 
The owl object instantiated from the Bird class is able to access the class and instance properties with dot notation. 
The Bird class, however, can only access the class property. 
Trying to access call gives the following error; AttributeError: type object 'Bird' has no attribute 'call'

class Bird:
    """
    Bird class
    """
    # class attribute
    definition = "a warm-blooded egg-laying vertebrate animal distinguished by the possession of feathers, wings, a beak, and typically by being able to fly."

    def __init__(self, kind, call):
        # instance attribute
        self.kind = kind
        self.call = call

    def description(self):
        """
        describe the bird
        """
        return f"A {self.kind} goes {self.call}" 
       
owl = Bird('Owl', 'Twit Twoo!')
print(owl.description())
print(owl.definition)
print(owl.call)
print(Bird.definition)
print(Bird.call)

CONSOLE
A Owl goes Twit Twoo!
a warm-blooded egg-laying vertebrate animal distinguished by the possession of feathers, wings, a beak, and typically by being able to fly.
Twit Twoo!
a warm-blooded egg-laying vertebrate animal distinguished by the possession of feathers, wings, a beak, and typically by being able to fly.
AttributeError: type object 'Bird' has no attribute 'call'

__________________________________________________-challenge

class ContactInfo:
    """
    Creates an instance of ContactInfo
    """
    about = "Contact information for customer"

    def __init__(self, name, email):
        self.name = name
        self.email = email

    def description(self):
        """
        Describes the instance of ContactInfo
        """
        return f"{self.name}: {self.email}"

# Print the class attribute 'about'
print(ContactInfo.about)

# Create an instance of the ContactInfo class
contact = ContactInfo("dave", "lister@email.com")

# Print the description from the contact object
print(contact.description())

CONSOLE
Contact information for customer
dave: lister@email.com

___________________________________________________________________Functions + classes: methods
a function within a class
you can define some logic to be reused
it can be used with dot syntax

______eg
class Bird:
    """
    Bird class
    """
    # class attribute
    definition = "a warm-blooded egg-laying vertebrate animal distinguished by the possession of feathers, wings, a beak, and typically by being able to fly."

    def __init__(self, kind, call):
        # instance attribute
        self.kind = kind
        self.call = call

    def description(self):
        """
        describe the bird
        """
        parrot = "Norwegian Blue"
        return f"A {self.kind} goes {self.call} and is {self.definition} It is not a {parrot}" 
       

owl = Bird('owl', 'Twit Twoo!')
print(owl.description())

CONSOLE
A owl goes Twit Twoo! and is a warm-blooded egg-laying vertebrate animal distinguished by the possession of feathers, 
wings, a beak, and typically by being able to fly. It is not a Norwegian Blu

_______________________________________________challenge
class BlogPost:
    """
    Creates an instance of BlogPost
    """
    def __init__(self, title, content, author):
        self.title = title
        self.content = content
        self.author = author

    def get_overview(self):
        """
        Returns an overview of the blog post with the title and author
        """
        return f"{self.title} by {self.author}"

    def full_info(self):
        """
        Returns the full information of the blog post with the title, content, and author
        """
        return f"Blog post: {self.title}. Content: {self.content}. Author: {self.author}"

# Create an instance of BlogPost
post = BlogPost("Python Classes", "Python is known as an object-oriented language...", "Code Institute")

# Print the returned value from the get_overview method
print(post.get_overview())

# Print the returned value from the full_info method
print(post.full_info())

CONSOLE
Python Classes by Code Institute
Blog post: Python Classes. Content: Python is known as an object-oriented language.... Author: Code Institute




_________________________________________________________________________OOP 
                                                                 OBJECT ORIENTED PROGRAMMING paradigm

___________________________________________________Object Oriented Programming

looks at entities, objects or actors in the problem domain
seeks to model their relationships, behaviour and interactions

OO allows programmers to reason about their code

eg  a customer object can own an account object
     customers can have properties like name, acc num, credit rating 
     an account may have properties like balance, overdraft, interest 

Objects can also have behaviours- an account may have a freez task

___________________________________________________________Subclassing and inheritance
a sub class
it inherits from its parent class
include the parent class in the initialiser method of the subclass

Subclassing is a useful way of creating a specialised version of a class with its methods but re-using existing methods 
and properties of the parent (or base) class

We could create a Parrot class which subclasses the Bird class created in previous units

We can use the existing methods on the parent/base class, and we don’t have to supply the bird kind or call because that’s
 coded into the Parrot class.

To subclass/inherit from a superclass/parent, add the name of the parent class inside parentheses as part of the 
subclass name.
To call a method on the parent class, precede the parent method name with the parent class name and a period.

______eg
created a Parrot class which subclasses Bird. 
can use the existing methods on the parent class, and we don’t have to supply the bird kind or call because that’s coded 
into the Parrot class.
They are inherited. We can add specialized behaviour such as the additional property of color.

class Bird:
    """
    Bird class
    """
    # class attribute
    definition = "a warm-blooded egg-laying vertebrate animal distinguished by the possession of feathers, wings, a beak, and typically by being able to fly."

    def __init__(self, kind, call):
        # instance attribute
        self.kind = kind
        self.call = call

    def description(self):
        """
        describe the bird
        """
        return f"A {self.kind} goes {self.call} and is {self.definition}" 


class Parrot(Bird):
    def __init__(self, color):
        Bird.__init__(self, 'Parrot', 'Kah!')
        self.color = color


parrot = Parrot('blue')
print(parrot.color)
print(parrot.description())

CONSOLE
blue
A Parrot goes Kah! and is a warm-blooded egg-laying vertebrate animal distinguished by the possession of feathers, wings, 
a beak, and typically by being able to fly.

_______________________________________________challenge
class JobListing:
    """
    Creates an instance of JobListing
    """
    def __init__(self, job_title, department):
        # Initialize the job_title and department attributes with the provided arguments
        self.job_title = job_title
        self.department = department
    
    def description(self):
        # Return a formatted string describing the job opening
        return f"Job opening for {self.job_title} in {self.department} department"

# Define the SalesManager subclass that inherits from JobListing
class SalesManager(JobListing):
    def __init__(self, salary):
        # Call the parent class's __init__ method to initialize job_title and department
        JobListing.__init__(self, "Sales Manager", "Sales")
        # Initialize the salary attribute with the provided argument
        self.salary = salary

# Create an instance of SalesManager with a salary of 45000
sales_manager = SalesManager(45000)

# Print the result of the description method, which should describe the job
print(sales_manager.description())  # Output: "Job opening for Sales Manager in Sales department"

# Print the salary attribute of the sales_manager instance
print(sales_manager.salary)  # Output: 45000


____________________________________________________________________________Mixins
a class that contains methods
you can use it to mix in extra properties or methods into a class
use by creating a class that inherits from the mixin class

A mixin is a class that provides methods to other classes but is not itself a parent class. 
You cannot create a subclass of a mixin. 
If you find yourself creating methods in your subclasses that are very similar, then this is an opportunity to move that method into a mixin.

The purpose of a mixin is to reduce the amount of unnecessary duplication of code. 
If you have a piece of logic that is frequently repeated in the subclasses, then move it to a mixin.

______eg
class Employee:
    """
    Base class for employees
    """
    # class attribute
    employee_no = 0

    def __init__(self, name, no_of_years):
        # instance attribute
        self.name = name
        self.no_of_years = no_of_years
        Employee.employee_no += 1
        self.employee_no = Employee.employee_no

    def details(self):
        """
        Method to return employee details as a string
        """
        return f"Name: {self.name}\n Years Worked: {self.no_of_years}\n Employee Number: {self.employee_no}\n"


class HolidayMixin:
    """
    Mixin to calculate holiday entitlement by years of service.
    Note that a mixin has no __init__ as you cannot create an instance of a mixin
    """
    def calculate_holidays(self, no_of_years):
        """
        Method that returns holidays as an integer if given no of years of service
        """
        BASE_HOLIDAY = 20
        bonus = 0
        holidays = BASE_HOLIDAY
        if no_of_years < 3:
            bonus = holidays + 1
        elif no_of_years <= 5:
            bonus = holidays + 2
        elif no_of_years > 5:
            bonus = holidays + 3
        return f'Holidays: {bonus}'


class DirectDeveloper(HolidayMixin, Employee):
    """
    Class for direct developer employee inheriting from 
    Employee class but also inheriting from HolidayMixin
    """
    def __init__(self, name, no_of_years, prog_lang):
        self.prog_language = prog_lang
        Employee.__init__(self, name, no_of_years)

    def calculate_salary(self):
        """
        Returns salary plus bonus as an integer
        """
        base = 30000
        if self.prog_language.lower() == 'python':
            bonus = base * 0.10
        else:
            bonus = 0
        return base + bonus

    def get_details(self):
        """
        Method to return direct developer details as a string
        Uses details() method inherited from Employee super class
        """
        return Employee.details(self) + f'Programming Language: {self.prog_language}'


eric = DirectDeveloper("Eric Praline", 2, "python")

# Prints out all the attributes of your eric instance using get_details method from DirectDeveloper
# If you use the details method from Employee then the Programming Language will not print
print(eric.get_details())
# The mixin method is usable for instance eric
print(eric.calculate_holidays(eric.no_of_years))
# Uses the calculate_salary method from DirectDeveloper
print(f'${eric.calculate_salary()}')

luigi = DirectDeveloper("Luigi Vercotti", 10, "php")
print(luigi.get_details())
print(luigi.calculate_holidays(luigi.no_of_years))
print(f'${luigi.calculate_salary()}')

CONSOLE
Name: Eric Praline
 Years Worked: 2
 Employee Number: 1
Programming Language: python
Holidays: 21
$33000.0
Name: Luigi Vercotti
 Years Worked: 10
 Employee Number: 2
Programming Language: php
Holidays: 23
$30000

____________________________________________________________________________Class Composition

a class that contains methods
A small child class with a method that inherits from the object
Create a class that inherits from the object

In object-orientated programming, two significant concepts are inheritance and composition.

Inheritance is what we have used up until now in this lesson.
    example, a subclass Parrot inherits from a Bird class. 
    The inheritance relationship, in this case, is that a Parrot is a Bird
    Any code where you use class Bird you could equally use class Parrot without changing the desired outcome of your 
    program.

Composition is where one class contains the object of another class. 
        we could have a Bird class and a Tail class.
        The composition relationship here would be that a Parrot has a tail so would inherit from both Bird and Tail.
        With composition, you cannot use class Tail interchangeably with Bird. The Tail class is not a subclass of Bird.

The purpose of both mixin and composite is to reduce the amount of unnecessary duplication of code.

class TicketMixin:
    """
    Mixin to calculate ticket price based on age
    """
    def calculate_ticket_price(self, age):
        if age < 12:
            return 0
        elif age < 18:
            return 15
        elif age < 60:
            return 20
        else:
            return 10

class Customer(TicketMixin):
    """
    Create instance of Customer
    """
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def describe(self):
        price = self.calculate_ticket_price(self.age)
        return f"{self.name} age {self.age} ticket price is {price}"

# Create an instance of the Customer class with name "Ryan Phillips" and age 22
customer = Customer("Ryan Phillips", 22)

# Print the description of the customer
print(customer.describe())


___________________________________________________________________Superclassing: Accessing the parent
the parent class
a subclass refers to the class it inherits from as a superclass
use with the super() function

To improve the maintainability of your code, use the super() function in place of the superclass name. 
herefore, if you ever change the superclass you only then need to change the argument in the subclass definition not 
everywhere else in the code.

___eg
 a simple example. When we look at simple shapes, you can see that a square is a special type of rectangle where the 
 width and height are the same. How would you show this relationship in object-orientated programming?

 class Rectangle:
    def __init__(self, height, width):
        self.height = height
        self.width = width

    def area(self):
        return self.height * self.width

    def perimeter(self):
        return 2 * (self.height + self.width)


class Square(Rectangle):
    def __init__(self, height):
        super().__init__(height, height)       #see the reference to superclass Rectangle is replaced with the function super() 
                                                in the subclass Square.


______eg
class Bird(object):
    """
    Bird superclass
    """
    def __init__(self, kind, call):
        # instance attributes
        self.kind = kind
        self.call = call

    def description(self):
        """
        Returns description string including instance attributes
        """
        return f'A {self.kind} goes {self.call}'


class Fowl(Bird):
    """
    Subclass of the superclass Bird
    """
    def __init__(self, kind, call, type):
        self.fowl_types = {'landfowl': 'Landfowl is an order of heavy-bodied ground-feeding birds that includes\n'
                                       'turkey, grouse, chicken, New World quail and Old World quail,\n'
                                       'ptarmigan, partridge, pheasant, junglefowl and the Cracidae\n',
                           'waterfowl': 'Waterfowl is an order of birds that comprises about 180 living species\n'
                                        'in three families: Anhimidae (the screamers), Anseranatidae\n'
                                        '(the magpie goose), and Anatidae,the largest family, which\n'
                                        'includes over 170 species of waterfowl,\n'
                                        'among them the ducks, geese, and swans.\n'}
        self.type = type
        # Uses super() function to state kind, call from superclass Bird
        super().__init__(kind, call)


    def description(self):
        """
        Returns string from superclass description method and
        appends a string to include additional information
        """
        return f'{super().description()} \nSome interesting facts about the {self.kind} : A {self.kind} is of type {self.type}. {self.fowl_types[self.type.lower()]}'

class Seabird(Bird):
    """
    Subclass of Bird superclass for sea birds
    """
    def __init__(self, kind, call, diving_depth):
        # super() is used to denote what is inherited from Bird
        super().__init__(kind, call)
        self.diving_depth = diving_depth

    def get_description(self):
        """
        Returns description from superclass using super() function
        Appends additional information as a string
        """
        return f'{super().description()} and also, a {self.kind} dives to a depth of {self.diving_depth} metres.'


gannet = Seabird('Gannet', 'Squawk', 3)
print(gannet.get_description())

duck = Fowl('Mallard', 'Quack!', 'Waterfowl')
print(duck.description())

CONSOLE
A Gannet goes Squawk and also, a Gannet dives to a depth of 3 metres.
A Mallard goes Quack! 
Some interesting facts about the Mallard : A Mallard is of type Waterfowl. 
Waterfowl is an order of birds that comprises about 180 living species
in three families: Anhimidae (the screamers), Anseranatidae
(the magpie goose), and Anatidae,the largest family, which
includes over 170 species of waterfowl,
among them the ducks, geese, and swans.

_______________________________________________________________________________challenge
class BaseOrderItem:
    """
    Creates instance of BaseOrderItem
    """
    def __init__(self, product, price, quantity):
        self.product = product
        self.price = price
        self.quantity = quantity
    
    def total_price(self):
        """
        Returns total based on price * quantity ordered
        """
        return self.price * self.quantity

class ShoeOrderItem(BaseOrderItem):
    """
    Creates instance of ShoeOrderItem
    """
    def __init__(self, product, price, quantity, size):
        super().__init__(product, price, quantity)
        self.size = size

    def describe(self):
        return (f"Order: {self.product} in size {self.size}, quantity: {self.quantity}, "
                f"total price: {self.total_price()}")

# Create an instance of ShoeOrderItem
shoe_order = ShoeOrderItem("Ladies Nike Trainers", 40, 2, 42)

# Print the description of the shoe_order
print(shoe_order.describe())

CONSOLE
Order: Ladies Nike Trainers in size 42, quantity: 2, total price: 80

______________________________________________________________Passing methods around
a method is an object
allows you to pass methods around
avoid repetition by reusing existing methods


___eg
If we return to the Parrot example, we see that we can use the description method belonging to the Bird class with an 
instance of the Parrot class. The method has been passed from the superclass to the subclass and is available for use by 
an object instantiated from the subclass.

class Bird:
    """
    Bird class
    """
    # class attribute
    definition = "a warm-blooded egg-laying vertebrate animal distinguished by the possession of feathers, wings, a beak, and typically by being able to fly."

    def __init__(self, kind, call):
        # instance attribute
        self.kind = kind
        self.call = call

    def description(self):
        """
        describe the bird
        """
        return f"A {self.kind} goes {self.call} and is {self.definition}" 


class Parrot(Bird):
    def __init__(self, color):
        Bird.__init__(self, 'Parrot', 'Kah!')
        self.color = color


parrot = Parrot('blue')
print(parrot.color)
print(parrot.description())

CONSOLE
blue
A Parrot goes Kah! and is a warm-blooded egg-laying vertebrate animal distinguished by the possession of feathers, wings, 
a beak, and typically by being able to fly.

_________________________________________________-challenge
class Employee:
    """
    Creates an instance of Employee
    """
    def __init__(self, name, annual_salary):
        self.name = name
        self.annual_salary = annual_salary
    
    def calculate_monthly_salary(self):
        """
        Calculate and return the monthly salary
        """
        return self.annual_salary / 12

class CustomerServiceEmployee(Employee):
    """
    Creates an instance of CustomerServiceEmployee
    """
    def __init__(self, name, annual_salary, department):
        super().__init__(name, annual_salary)
        self.department = department

# Create an instance of CustomerServiceEmployee
cs_manager = CustomerServiceEmployee("Kelly Johnson", 42000, "Customer Service")

# Calculate Kelly's monthly salary
kellys_monthly_salary = cs_manager.calculate_monthly_salary()

# Print Kelly's monthly salary
print(kellys_monthly_salary)

CONSOLE
3500.00

__________________________________________________________________Decorators in OPERATORS
a software design pattern
alters methods
by wrapping them up in a decorator

A decorator is a way in Python to add new functionality to an existing method without modifying its structure. 
This is useful as you do not need to create new functionality in your code if a decorator already exists for that purpose.

if we return to Bird objects again. We have an instance variable called fowl_types with information about the species.
We don’t want to accidentally corrupt this information. Classes should only share what data is needed.
This is known as Encapsulation and Separation of Concerns

To mark fowl_types as private and only available to other methods in the class, we have prefixed the name with a dunder
Now we cannot access it but the new method within the class named fowl_types() can

______eg
class Bird(object):
    """
    Bird superclass
    """
    def __init__(self, kind, call):
        # instance attributes
        self.kind = kind
        self.call = call

    def description(self):
        """
        Returns description string including instance attributes
        """
        return f'A {self.kind} goes {self.call}'


class Fowl(Bird):
    """
    Subclass of the superclass Bird
    """
    def __init__(self, kind, call, category):
        self._fowl_types = {'landfowl': 'Landfowl is an order of heavy-bodied ground-feeding birds that includes\n'
                                       'turkey, grouse, chicken, New World quail and Old World quail,\n'
                                       'ptarmigan, partridge, pheasant, junglefowl and the Cracidae\n',
                           'waterfowl': 'Waterfowl is an order of birds that comprises about 180 living species\n'
                                        'in three families: Anhimidae (the screamers), Anseranatidae\n'
                                        '(the magpie goose), and Anatidae,the largest family, which\n'
                                        'includes over 170 species of waterfowl,\n'
                                        'among them the ducks, geese, and swans.\n'}
        self.category = category
        # Uses super() function to state kind, call from superclass Bird
        super().__init__(kind, call)

    @property
    def fowl_types(self):
        return self._fowl_types[self.category.lower()]


    def description(self):
        """
        Returns string from superclass description method and
        appends a string to include additional information
        """
        return f'{super().description()} \nSome interesting facts about the {self.kind} : A {self.kind} is of type {self.category}. {self._fowl_types[self.category.lower()]}'


mute = Fowl('Swan', 'honk', 'Waterfowl')
print(mute.description())
print(mute.fowl_types)

CONSOLE
A Swan goes honk 
Some interesting facts about the Swan : A Swan is of type Waterfowl. Waterfowl is an order of birds that comprises about 
180 living species
in three families: Anhimidae (the screamers), Anseranatidae
(the magpie goose), and Anatidae,the largest family, which
includes over 170 species of waterfowl,
among them the ducks, geese, and swans.

Waterfowl is an order of birds that comprises about 180 living species
in three families: Anhimidae (the screamers), Anseranatidae
(the magpie goose), and Anatidae,the largest family, which
includes over 170 species of waterfowl,
among them the ducks, geese, and swans.


____________________________________________________________________________________BUILT IN FUNCTIONS AND TOOLS

______________________________________________________________________The import statement
a python command
imports fromanother python module
use by putting the import command at the top of the file

When you create a Python program, you split your code up into different files to avoid repetition.
These files are known as modules. 

Python has built-in modules that we can import from as well. We do this with the import statement.

______eg
example, we have a division function in a divide.py module. 
we have imported the division function from the divide.py module, which allows us to use the division function using the 
division() syntax directly. 
However, we do not have access to the mod function unless we also add a from divide import mod statement in main.py.
To avoid this, we could have used import divide to import the whole module and then used divide.division or divide.mod 
directly.

MAIN.PY 
from divide import division

print(division(4, 2))

DIVIDE.PY
def division(numerator, denominator):
    result = numerator / denominator
    return result

def mod(numerator, denominator):
    result = numerator % denominator
    return result

CONSOLE
2


_______________________________________________challenge
MAIN.PY
import helpers

list_integers = [1,2,3,4,5]

addition = helpers.add_integers(list_integers)
print(addition)

multiplication = helpers.multiply_intergers(list_integers)
print(multiplication)

HELPERS.PY
def add_integers(list_integers):
	total = 0
	for x in list_integers:
		total += x
	return total
    
def multiply_intergers(list_integers):
    total = list_integers[0]
    for x in list_integers:
        # As it is a tuple you can use the in keyword to iterate 
        total = total * x
    return total

CONSOLE
15
120


_______________________________________________________________________________math

a built in library
provides standard mathematical functions
by importing at the top of the module

Math.pi
Math.random()
Math.abs()
Math.min()
Math.max()
Math.floor()
Math.ceil()
Math.round()
Math.pow()
Math.sqrt()

___eg
example, we have printed the value of pi. Also, we have used the square root function. 
As math is a built-in library it comes with Python, and there is no need to install it separately.

import math

print(math.pi)

print(math.sqrt(4))

CONSOLE

3.141592653589793
2.0

_______________________________________________________________________________challenge

import math

# Assign value to the num variable
num = 81.5

# Round up the value of num using the ceil() method and assign to round_up
round_up = math.ceil(num)
print(round_up)

# Round down the value of num using the floor() method and assign to round_down
round_down = math.floor(num)
print(round_down)

# Get the square root of the round_down variable using the sqrt() method and assign to square_root
square_root = math.sqrt(round_down)
print(square_root)

CONSOLE

82
81
9.0

_______________________________________________________________________________________________datetime
a built in library
provides classes for manipulating dtes and times
by importing at the top of the module

Dates and times can be tricky to work with, when coding. This is due to the differences in how a user may input a date.
The built-in datetime library allows you to manipulate dates and times.

___eg
 we have displayed the current date and time on the repl.it server where this code is running. 
 date contains a year, month, day, hour, minute, second and microsecond
 The library contains methods to access that data.
 We have obtained the year and printed it to the console.

 common usage of the datetime library is to get a readable string from the datetime object
 There is a method called strftime() that takes a parameter format to return the string as you would like to display it 
 to your user

 In the first part of the runnable example we have shown the day of the week.

 We can also access date information with python using datetime instance methods such as date() and time().


from datetime import datetime

x = datetime.now()
print(x)
print(x.year)
print(x.strftime("%A"))

the_date = datetime.now().date()
print(the_date)

the_time = datetime.now().time()
print(the_time)

CONSOLE

2024-06-07 10:31:15.349646
2024
Friday
2024-06-07
10:31:15.349793

_______________________________________________________________________________challenge

from datetime import datetime

# Get the current date and assign it to the today variable
today = datetime.now().date()

# Print the value of the today variable
print(today)

CONSOLE
2024-06-07

_______________________________________________________________________________________________io

a built in library
provides functions for taking data in and producing an output
by importing at the top of the module

There are many basic in/out (I/O) functions in Python, with which some at least you are already familiar. 
A print statement is the most basic output. 
also seen examples of taking input from a user with the input() function.
These are, of course, only useful when using a command-line application where the input and output use the terminal.

In real-world applications, you might also be reading from and writing to files on the computer where the code is running.

MAIN.PY

f = open('source.txt')
lines = f.read()
f.close()
print(lines)

SOURCE.text
The io.py library is a built-in library of tools in Python to work with data input and output. 

CONSOLE
The io.py library is a built-in library of tools in Python to work with data input and output. 

___________________________________________________challenge
MAIN.PY
# Step 1: Open the file
file = open('lyrics.txt', 'r')

# Step 2: Read the contents of the file
lyrics = file.read()

# Step 3: Close the file
file.close()

# Step 4: Print the contents
print(lyrics)

LYRICS.txt
Row, row, row your boat
Gently down the stream
Merrily merrily, merrily, merrily
Life is but a dream

CONSOLE
Row, row, row your boat
Gently down the stream
Merrily merrily, merrily, merrily
Life is but a dream

__________________________________________________________________________________________os
a built in library
provides functions for working with the operating system
by importing at the top of the module

The os library provides a way of using the operating system (os) functionality. 
The operating system is the software that interfaces between the hardware and user on a computer.
Common operating systems would be Windows, macOS, Linux or iOS.
A frequent use for this would be accessing the environment variables. 

Every computer has a set of environment variables listing information on how the machine is set up
Examples of this would be the directory structure of the home directory or the computers users profile.

___eg

example,
 we use the get current working directory function getcwd() to find the directory in which the python file is located.
 We can also list the files or directories listdir() within a directory.

import os

print(os.getcwd())
print(os.listdir('/home/user'))

CONSOLE
/home/user
['main.py']

________________________________________________________________________________________os.path()

a built in module in the os library
provides functions for manipulating path names
by importing at the top of the module

Within the os library, there is a module named path.
This allows you to manipulate the pathnames on the operating system of the computer on which you are running the code.
This is useful when saving data to the local operating system. 
The os.path() methods allow you to dynamically create path names so you can connect to files on the operating system 
  and save files where you intend to.

______eg
example, we have taken the absolute path and joined it with the current working directory.
This uses the join() method of the path module. 

There is also a split() method allowing you to split a path. In this case, we have split the filename from the pathname 
    and assigned them to a tuple.
he splitext() method allows you to split the module name from its file extension


import os

# This is how you would join two paths in your code
print(os.path.join('/home/runner/', 'os'))

path = "/home/runner/os/main.py"
# Splits the path into a pair (head, tail) where the tail is the end of the pathname
# The tail is after the / and the head is the pathname up to that point 
(dirname, filename) = os.path.split(path)
print(f'The directory path is {dirname}')
print(f'The filename is {filename}')
# Splits the filename into a pair (root, ext)
# The root is before the dot and the ext contains the dot with the suffix after it
(module, extension) = os.path.splitext(filename)
print(f'The module is {module}')
print(f'Its file suffix is {extension}')

CONSOLE

/home/runner/os
The directory path is /home/runner/os
The filename is main.py
The module is main
Its file suffix is .py


___________________________________________________________________________________random
a built in library
provides pseudo random numbers
by importing at the top of the module

An everyday computing problem is making a random choice. 
Computers are not good at being random.
The random library generates pseudo-random numbers that are suitable for most purposes. You can use these for games or 
simple statistical checks.

______eg
you can see how you would generate a random float, integer or choice. You can also shuffle existing data structures.

import random

print(f'A random float between 0 & 1.0: {random.random()}')
print(f'A random int between 0 & 10: {random.randrange(11)}')
print('A random choice from a list: ' + random.choice(['paper', 'scissors', 'rock']))
deck = ['hearts', 'diamonds', 'spades', 'clubs']
random.shuffle(deck)
print(deck)

CONSOLE
A random float between 0 & 1.0: 0.6602286498381412
A random int between 0 & 10: 9
A random choice from a list: rock
['hearts', 'spades', 'diamonds', 'clubs']

______________________________________________challenge
import random

# Define the function to generate a list of 10 random integers
def ten_rand_nums():
    return [random.randint(0, 100) for _ in range(10)]

# Call the function and assign the returned value to result
result = ten_rand_nums()

# Print the original result list
print("Original list:", result)

# Shuffle the result list
random.shuffle(result)

# Print the shuffled result list
print("Shuffled list:", result)

CONSOLE
Original list: [23, 33, 70, 60, 61, 62, 91, 62, 25, 89]
Shuffled list: [23, 70, 62, 62, 25, 89, 33, 91, 61, 60]

_____________________________________________________________________________Third Party languages
libraries created for python
prewritten code
us by importing what you need

In addition to the built-in libraries, as Python is open source, anyone can create software and share it with the 
 community. 
A library is a collection of modules that have some common functionality.
There is a Python Package Index (pypi.org) where these open source projects are shared.

    NumPy      pandas     django       Scrapy

______eg
 we are using a third-party library named numpy.
 widely used library for scientific computing

 give the package name an alias (np in this case), so we don’t have to type it out each time. 
 Numpy extends the abilities of Python into scientific computing
 ere we are creating a simple one-dimensional array. 
 The repl.it already has numpy installed.

  If you were trying this on your computer, you would have to install numpy locally as it is a third-party library rather 
     than a built-in library installed with Python.

import numpy as np 

a = np.array([1, 2, 3])

print(a)

CONSOLE
[1 2 3]

____________________________________________________challenge
from dateutil import parser

# Given log line
log_line = 'INFO 2020-07-03T23:27:51 Shutdown complete.'

# Parse the log line to extract the timestamp
timestamp = parser.parse(log_line, fuzzy=True)

# Print the extracted timestamp
print(timestamp)

CONSOLE
2020-07-03 23:27:51

_________________________________________________________________________PYTHON I/O AND EXCEPTOPN HANDLING

__________________________________________________________What are Input/Output operations
Taking user inputs and storing program outputs
Persists data
with io library methods

input devices- recieve info
Processor (cpu)- Processes the information
Output devices- produce the output

going to have a look at file input and output or I/O for short. 

Data that is taken from the user for example from a keyboard can be written to file. 
Data in a file can be read and output to the screen.

Most programs store data in memory while they're running.
Choosing the correct data structure can make all the difference in the performance of an application. 
A skilled developer knows how to use and combine smaller data structures into more substantial and more elaborate models 
    in memory

as great as these models are, anything held in RAM, or Random Access Memory, is volatile
that means that when the program shuts down, either by deliberately exiting or as a result of a crash, then the data is 
  lost.

as data gets more and more elaborate, some programs just can't store all of the information they work with, in the memory 
   at the same time.

going to have a look at how to store data on a disk using files.
 ways of storing data, for example in a database, 


___________________________________________________________________________Reading Data from a user
Taking user inputs
allows user interactions
with input methods

When working with computers, we use what is called an interface to interact with the computer. 
Graphical User Interface (GUI). The GUI is where we execute applications from our Desktop
              eg opening folders from My Computer
                 creating Documents in Microsoft Office,
                 browsing the web with Chrome or Firefox.

While we’re working with Python, and providing output to a user, we’re using the Command Line Interface or CLI.
This interface is text-based, as opposed to the graphics-based interface we’re all used to seeing, but just remember that 
      all we’re doing is taking input and outputting information to the user.

how we can receive some input from a user
use the input function.
takes a string as an argument.- This is the prompt the user will see.
The input function stops the running of the program and waits for the user to enter data in the command line and press return.
Whatever the user inputs is converted to a string.
Therefore if you need it as a number, you need to convert it.

______eg

username = input("Type in your name and press return: ")
# The programme will remain stopped until you respond to this prompt with some text and press the return key
# As the value type that is received from an input is a string
# We need to convert it to a number to be able to use it on line 7
# We can do this by wrapping the input inside the int() method
age = int(input("Please enter your age: "))

days = 365 * age
# days is a number
# To concatenate it to the string we have to convert it to a String
# Notice below we do this like: str(days)
print("Hello " + username + ", you have been alive for at least " + str(days) + " days")

CONSOLE 
# creates input boxes as program runs through, culminating in:

Runnable example Taking-User-Input
Run Code
main.py
username = input("Type in your name and press return: ")
# The programme will remain stopped until you respond to this prompt with some text and press the return key


Console:
Type in your name and press return: Alex
Please enter your age: 39
Hello Alex, you have been alive for at least 14235 days

_________________________________________________________________________Returning data to the user
gives the user feedback
with print

In a command-line Python, program output can be given in several ways:
                    simple statements
                    An expression statement can be used to compute and write a value.
                    assertion and raise statements- statements in the terminal when an error occurs. 

                    The most frequently used output you have seen is the print function. This allows you to output data 
                         in a human-readable format.

fancier ways to format our output.

       Statement- the most basic output- 
                 g, we have a simple one-line expression (10 + 20) which is assigned to a variable i.
                    When we print this to the console it is considered to be a statement.

    Formatted string literals- a way to improve the human readability of the output.
            eg. assigned a string to variable language and an integer to variable version.
                With string literals, we can pass these values directly to the print statement with no need to convert 
                data types.

     expressions. - 
              The value of pi from the math library is expressed within the print statement
               A format specifier can be included after the colon. In this case, the value is rounded to two significant figures. 
            f instead of a format specifier an integer is placed after the colon, the field will be set to a minimum 
            character value equal to the integer value.

          eg- Here we have chosen 25 to take into account the longest string.

When including a non-keyboard character such as the pound sterling, it can be done by using the chr() and the Unicode 
value (163 in this case).

______eg
import math

i = 10 + 20
print(i)
language = "Python"
version = 3
print(f'We are using {language}{version}')
# Here the format specifier .2f is used to truncate at 2 decimal places
print(f'The value of pi to 2 decimal places is {math.pi:.2f}')
# The currency symbol for pounds sterling has Unicode character number 163
pound = chr(163)
tabulate = {'Egg & Spam': 1, 'Egg, Bacon & Spam': 1.5, 'Egg, Bacon Sausage & Spam': 2, }
# Loops over a dictionary of menu items as keys and prices as values
for item, price in tabulate.items():
    # The format specifiers here denote a minimum width of 25 and 5 characters
    print(f'{item:25} - {pound}{price:5}')

CONSOLE
30
We are using Python3
The value of pi to 2 decimal places is 3.14
Egg & Spam                - £    1
Egg, Bacon & Spam         - £  1.5
Egg, Bacon Sausage & Spam - £    2

___eg
includes expressions within the formatted string literals. Additionally, the newline (\n) is used to add a new line after 
the second print statement. This also helps make the output easier to read.

for number in range(99, 0, -1):
    line_one = f"{number} bottle(s) of beer on the wall. {number} bottle(s) of beer"
    line_two = f"Take one down, pass it around. {number-1} bottle(s) of beer on the wall\n"

    print(line_one)
    print(line_two)

CONSOLE
99 bottle(s) of beer on the wall. 99 bottle(s) of beer
Take one down, pass it around. 98 bottle(s) of beer on the wall
98 bottle(s) of beer on the wall. 98 bottle(s) of beer
Take one down, pass it around. 97 bottle(s) of beer on the wall
97 bottle(s) of beer on the wall. 97 bottle(s) of beer
Take one down, pass it around. 96 bottle(s) of beer on the wall                 # and so on


_______________________________________________________________________Reading data from a file
how to open a file for reading in python
opens a file in memory so we can read, display and manipulate the contents
by using Python 'open', 'read', and 'readlines' methods

most uncomplicated persistent storage is a text file
You can save lines of text in the file then use python io to open the file and read the contents
several methods to do this:
          use readlines() -which reads all the lines into a list
          readline() which reads one line at a time, 
          read() which reads the entire file
          eek() which moves to a particular point in a file.

when you open a file, you are reading or writing to a particular position within the file.
         If you use readline to read a line, your location within the file is advanced by a line. 
         The next time you read a line, the line will be read from the end of the last line

files don’t have lines. 
      A file is just one long sequence of bytes (the computer’s way to store characters),
       but when Python sees a line separator such as ‘\n’, it interprets that as marking the break between two lines.

______eg
the code opens the file, reads the lines it contains into a variable called lines. 
When printed out, we see that it's a list of strings.

the 'r means that the file is opened as read-only.

can also see that each line contains the newline character '\n'. makes sense because the file data.txt contains 
four separate lines. 

the readlines method splits the data read from the files at those newline characters, to create a line of strings. 

use the read method instead of readlines. All of the data will be read into a single string, including the newline 
 characters.

When the string is printed to the console now, it just appears as text, not a list of strings. 
The newline characters cause the string to be displayed over several lines.

MAIN.PY
f = open('data.txt', 'r')
lines = f.readlines()
f.close()
print(lines)

DATA.txt
This is the first line
And this is the second
Here is the third line
And here the fourth

CONSOLE
['This is the first line', 'And this is the second', 'Here is the third line', 'And here the fourth']

_____________________________________________-challenge
def get_content(file):
    # Open the file in read mode and assign the file object to the variable 'song'
    song = open(file, 'r')
    
    # Read the entire content of the file and assign it to the variable 'lines'
    lines = song.read()
    
    # Close the file to free up system resources
    song.close()
    
    # Return the content of the file
    return lines

# Call the function 'get_content' with the argument "lyrics.txt"
# and assign the returned value to the variable 'lyrics'
lyrics = get_content("lyrics.txt")

# Print the contents of the 'lyrics' variable to the terminal
print(lyrics)


CONSOLE
Twinkle, twinkle, little star
How I wonder what you are
Up above the world so high
Like a diamond in the sky
Twinkle, twinkle little star
How I wonder what you are


_____________________________________________________________________________Runtime errors
an error that does not fall into any defined categories
the error is raised and displayed to the user
with the try  except syntax

Python error messages are called exceptions.
When an error occurs, an exception is raised. 

All exceptions are instances of a class BaseException
The exceptions can be generated either by the interpreter while running the code or by functions in the code.

As a developer, you can raise these exceptions to deal with errors caused by incorrect user input, for example

There are many specific exceptions in Python; 
              eg ZeroDivisionError raised when the second argument of a division or modulo operation is zero. 

                  However, if an error does not fall into one of these specific categories, a RuntimeError will be raised. The associated string will explain what has gone wrong.


______eg
the code will print text to the terminal if 1 or 2 is entered.
However, what happens if a user enters another number or a string instead? 
              In the else, we have used the keyword raise to raise a RuntimeError exception if this happens. 
A RuntimeError is posted in the terminal,

def choices(n):
    if n == 1:
        print("First item chosen")
    elif n == 2:
        print("Second item chosen")
    else:
        raise RuntimeError

choices(3)

CONSOLE
RuntimeError: 

______________________________________________________________________Try statements
A way to hande errors
if an error is seen the except clause is to run in response
use with the try except syntax

 previous unit, we saw that we could raise an error when a user does something unexpected. 
      However, the program still crashed.

better to catch and handle these exceptions in such a way that your application continues to run.

Python has a try block in which you put code where you anticipate an error could occur- caused by a users input or 
     corrupt data in a file.
     program runs any code after the try statement in the usual manner. However, if an error occurs rather than raise an 
            exception in the terminal, it runs code in a following except block. 
    After the except statement, you write the code for what you want to do in cases where an error occurs.
          If this is user input, it might just be a message to the user that the data was invalid and please try again.
          If it is data from a file, then you might just skip the bad data points and carry on

the try block allows you to test a code block for errors.
The except block enables you to handle the errors.

______eg
we have asked the user for a number. 
        This code block is wrapped in a try block and runs exactly as though the try block was not there as long as the 
        user enters numbers.
However, if the user enters a letter, for example, there is an error, and the except block code is run. 
         In this case, we just print ‘Not a number’, but crucially the code keeps running and asks the user for input 
         again
    
The error is caught and handled.

while True:
    try:
        x = int(input('Enter a number.'))
        print(f'Number is {x}')
    except ValueError:
        print('Not a number')
CONSOLE
Enter a number.pp
Not a number
Enter a number.9
Number is 9
Enter a number.8
Number is 8
Enter a number.h6
Not a number

______________________________________________challenge
# Define the cars dictionary
cars = {'ford': 10, 'opel': 5}

# Define the get_val function
def get_val(key):
    try:
        # Try to return the value for the given key from the cars dictionary
        return cars[key]
    except KeyError:
        # If the key does not exist in the dictionary, return None
        return None

# Call the get_val function with "ford" and assign the result to the variable 'ford'
ford = get_val("ford")
# Print the value of 'ford'
print(ford)

# Call the get_val function with "hyundai" and assign the result to the variable 'hyundai'
hyundai = get_val("hyundai")
# Print the value of 'hyundai'
print(hyundai)

CONSOLE
10
None

__________________________________________________________________________Try and except statements
a way to handle errors
if an error is seen the except clause runs in response
use with the try/ except syntax

last example, we handled the error by telling the user that they had not entered a number.

No exception, however, was raised so there is no record of the error.
As a developer, you might want to record the incidence of this error, so perhaps you can improve your UX. 
In a case where it is not user data entry but a file, you might want to record how many data points are bad. 

To do this, you can raise an exception in the except block.

In some cases, you may anticipate more than one type of error.
Python allows you to have multiple except statements. I

______eg
have three except blocks. If more than one is valid, the first exception raised is the one you’ll see
Here we check for division by zero and an inappropriate value entered. 
If another error occurs that the first two except blocks don’t catch then the third block catches it. 

while True:
    try:
        a = int(input("Please enter an integer as the numerator: "))
        b = int(input("Please enter an integer as the denominator: "))
        print(a / b)
    except ZeroDivisionError:
        print("Please enter a valid denominator.")
    except ValueError:
        print("Both values have to be integers.")
    except Exception:
        print('Another error has occurred')

______________________________________________________________________________Catching specific errors
a way to handle specific errors
if an error is seen the except clause is run in response
use with the try/except syntax and a specific Exception name

In addition to the basic RuntimeError, you have seen the use of ValueError and ZeroDivisionError. 
These are more specific exceptions provided by Python

When writing your code, it is essential to think about what possible errors might happen and how to handle them.
It is a good idea to test your code as you go. 

What happens when you enter incorrect values for your function arguments, for example? 
    
    Using more specific exceptions can make it quicker to debug what has gone wrong with your code. 
    When you raise an exception, you can include a string of text to provide information pertinent to your code.

---eg
return to the previous example, we see that multiple specific exceptions can be included in one except block if they are 
   added to a tuple in the except statement.

while True:
    try:
        a = int(input("Please enter an integer as the numerator: "))
        b = int(input("Please enter an integer as the denominator: "))
        print(a / b)
    except (ZeroDivisionError, ValueError):
        print('An error has occurred')

A specific exception can be raised anywhere in your code to catch errors.
     In the example, we have a try block which counts down from 5 to -5 but raises an exception for negative numbers. 
     At the point this exception is raised the except block is run

This time a list is looped through and an exception is raised if a non-integer value is seen.
      This time a list is looped through and an exception is raised if a non-integer value is seen.
   
___________________________________________-challenge
try:
    # Try to print a variable that has not been defined
    print(non_existent_variable)
except NameError:
    # Handle the NameError and print a message to the terminal
    print("Variable not defined")


__________________________________________________________________ Catching Generic Errors With “as”
a way to handle specific errors
allows access to the attributes of the exception pbject
use with    except  Exception as err    syntax”

The built-in exceptions contain information about the error. 
Up till now, we have just displayed the exception in the terminal. 
The exception object includes the error message and also additional arguments.

______eg
In this example, we have passed the UnicodeError exception to a variable e. Then we have access to the various attributes.

def encode_name(name):
    try:
        name = name.encode('ascii')
    except UnicodeError as e:
        print(f'The name {e.object} has a character at position {e.start} that cannot be encoded in {e.encoding} due to {e.reason}')
    return name
    
encode_name('Stéfan')
______eg
below there is no file book.txt, so the except block runs. 
The exception OSError is passed to variable e, so we have access to the arguments. 
The OSError exception is for operating system errors such as file not found. 
Then we pass the arguments to a tuple with variable names errno and strerror.
These are the numeric error code and corresponding error message respectively. 
      We could also have used the filename argument, for example.

try:
    f = open('book.txt')
    s = f.readline()
except OSError as e:
    errno, strerror = e.args
    print(f"There is an I/O error number, {errno}: {strerror}.")

CONSOLE
There is an I/O error number, 2: No such file or directory: 'book.txt'.

______________________________________________________-challenge





__________________________________________________________________________Else and Finally statements
Additional clauses to deal with no exception or a clean-up that must run
Runs code after the exception is handled
With else or finally syntax

The try-except has an optional else clause. 
placed after all of the except clauses and deals with any code that must be executed in the case where the try clause does not raise an exception.
code placed in the try block should only be the code where you are anticipating the exception
Any other code that should run along with it should be placed in the else block. 

there is an additional optional clause finally, which is the last clause to run.
It runs whether or not an exception has been raised.
It is intended for any ‘clean-up’ code that must run regardless of whether an exception was caught or not.

___eg

 we have a function that opens a text file, counts the lines and prints the opening line of the file.
 The try block catches if a file does not exist and the except block deals with the error so that the program does not 
     crash. 
The else block deals with the code that should run in the case of no error (the file exists).
The finally block runs whether or not the file exists.
Here it just lets the user know that the function has complete. Note that it runs after the try, except and else blocks.

MAIN.PY
def linecount(filename):
    """
    Counts the lines in a text file.
    Prints the opening line of a text file. 
    """
    try:
        f = open(filename, 'r')
        s = f.readlines()
    except OSError as e:
        # OSError exception is used as it deals with system errors such as I/O errors
        # OSError returns an error code (errno) and message (strerror)
        errno, strerror = e.args
        print(f"There is an I/O error number, {errno}: {strerror}.")
    else:
        # This is the code that does the line counting
        print(f'{filename} is {len(s)} line long.')
        print(f"The opening line of {filename} is '{s[0]}'")
        f.close()
    finally:
        # This will print whether the line count has been successful or not
        print(f'Finished with {filename}.')
    
linecount('gulliver.txt')
print("\n")
linecount('swift.txt')

gulliver.txt
My father had a small estate in Nottinghamshire; I was the third of five
sons. He sent me to Emmanuel College in Cambridge at fourteen years old,
where I resided three years, and applied myself close to my studies;
but the charge of maintaining me, although I had a very scanty
allowance, being too great for a narrow fortune, I was bound apprentice
to Mr. James Bates, an eminent surgeon in London, with whom I continued
four years; and my father now and then sending me small sums of money, I
laid them out in learning navigation, and other parts of the mathematics
useful to those who intend to travel, as I always believed it would be,
some time or other, my fortune to do. When I left Mr. Bates, I went down
to my father, where, by the assistance of him, and my uncle John and
some other relations, I got forty pounds,[2] and a promise of thirty
pounds a year, to maintain me at Leyden. There I studied physic two
years and seven months, knowing it would be useful in long voyages.

CONSOLE
gulliver.txt is 14 line long.
The opening line of gulliver.txt is 'My father had a small estate in Nottinghamshire; I was the third of five'
Finished with gulliver.txt.
There is an I/O error number, 2: No such file or directory: 'swift.txt'.
Finished with swift.txt.


when using IO, you always should close the file when you are finished working on it. 
As this is such an important issue, Python has included a with statement to deal with it. 
Behind the scenes, it is in effect a type of try-finally statement.

----
f = open(filename)
try:
    # My Code
finally:
    f.close() 
----

In reality, what is happening is that special methods __enter__ and __exit__ are used.
---
f = open()
f.__enter__()
try:
    # My Code
finally:
    f.__exit__()
---

You do not need to type any of this code. Just use the with statement as follows.
---
with open(filename) as f:
       #My Code
---
As you can see we have refactored the code to use this syntax. No explicit file close statement is required.

______eg
cars = {'ford': 5, 'hyundai': 6}

def update_cars(data, key, val):
    try:
        data[key]
    except KeyError as e:
        print(f"No key {e} in dictionary")
    else:
        data[key] = val
    finally:
        return data


# Call the update_cars function with cars, "mazda", 8 as arguments
updated_cars = update_cars(cars, "mazda", 8)



# Do Not Place Code Below This Line 
# This will print out the cars dictionary after the update_cars function is called
print(updated_cars)

CONSOLE
No key 'mazda' in dictionary
{'ford': 5, 'hyundai': 6}